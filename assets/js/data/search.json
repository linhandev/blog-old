[ { "title": "Mail", "url": "/posts/Mail/", "categories": "", "tags": "", "date": "2022-08-17 00:00:00 +0800", "snippet": "https://github.com/docker-mailserver/docker-mailserver#usageDMS_GITHUB_URL=’https://raw.githubusercontent.com/docker-mailserver/docker-mailserver/master’wget “${DMS_GITHUB_URL}/docker-compose.yml”wget “${DMS_GITHUB_URL}/mailserver.env”https://github.com/docker-mailserver/docker-mailserver#create-a-docker-compose-environmentdocker-compose updocker-compose up -ddocker exec -ti setup email add/del &amp;lt;user@domain&amp;gt;注意：letsencrept 的证书可能用 sym link，docker 里和 host 里的链接需要完全相同，volume 的文件夹需要包含 link 文件和原文件https://app.sendinblue.com/" }, { "title": "Recist", "url": "/posts/principles/", "categories": "Med, Tumor", "tags": "Med, Tumor", "date": "2022-02-27 16:10:00 +0800", "snippet": "Belmont Report: Ethical Principles for research involving human subjects Respect for Persons: Individuals should be treated as autonomous agents 弱势群体应被额外保护 Imformed Concent Information 足够作出决定:就算志愿者了解这个治疗并非必须而且自己没有完全理解也能决定 Comprehension Volunteariness:压力或报酬 Privacy Beneficence:避免伤害并追求 Systematic Assessment of Risks and Benifits 对志愿者和其他可能获益的患者 Minimization of Risk 动物实验，更安全的流程… Justice:公平的分担风险和获益 因为实验需要选人，不因为方便target特定人群 纽伦堡原则 自愿同意 有科学价值，无法用其他方式达成 研究的获益大于风险，应该有动物实验或者其他研究佐证实验可能的获益 志愿者可以随时退出，实验者要有在严重伤害产生前终止实验的准备 避免任何不必要的伤害，对任何可能的伤害应该做好准备IRB Risk/Anticipated Benefit Analkysis Informed Concent Assent Privacy/Confidentiality Research Plan for Collection, Storage and Analysis of Data Research Design/Methods Additional Information " }, { "title": "Recist", "url": "/posts/tumor/", "categories": "Med, Tumor", "tags": "Med, Tumor", "date": "2022-02-27 16:10:00 +0800", "snippet": "Recist解剖角度评价肿瘤负担水平和变化，大小和时间两个维度。主要面向二期临床实验。恶性脑瘤和恶性淋巴瘤有单独标准。二期临床试验一般间隔6～8周。Recist Response Evaluation Critiria In Solid Tumors 2000 1.0，2009 1.1 有其他标准的实体肿瘤 恶性脑瘤 恶性淋巴瘤 纯1D解剖，没有3D，没有功能iRecist immune Response Evaluation Critiria In Solid Tumors 用于免疫治疗评效 2017 和放化疗区别 免疫反应有动员激发的过程，见效比较慢 超进展：最开始4～6周可能增长超过1倍 可能有炎性浸润，片子上肿瘤容易变大 混合缓解：主诉主观获益，但是片子里客观未获益 测量方法 影像 CTA最好，一些情况MRI也可，造影过敏增强核磁 CT可测量病灶最小为层厚2倍，一般层厚5mm 至少要在两个层面里看到病灶 x光最小20mm 标记物 不能单独用，必须结合影像 如果基线水平高，判断CR必须恢复正常 不可测量 太小 肿瘤长径&amp;lt;10mm 恶性淋巴瘤短径&amp;lt;15mm 没法测量 没有固定边界 各种积液 边界不清 炎症 脑膜疾病、腹水、胸膜或心包积液、炎症乳腺疾病、皮肤或肺的淋巴管受累，经体格检查发现的腹部肿块/腹部器官肿大 成骨性转移 溶骨性转移吃完骨头会生成软组织，可以测 囊肿 单纯囊肿里面是水，不是恶性，不记 转移病灶，混合囊肿和实质性可以记，首选实质性的 局部治疗后 里面可能已经没有活性成分 除非有明确进展不记 靶病灶 要可测量 每个器官不超过2个，总数不超过5个 只有一个器官就最多2个 挑选 分散 清晰可重复 边界清晰 各个方向径差不多 尽量大 淋巴结 挑短径15mm以上的 选为靶病灶之后，短径只要还能测就一直记 基线记录 时间上接近治疗开始，不早于治疗开始4周 一个器官里一堆记器官弥散，不用一个一个写 直径和 所有靶病灶直径和（肿瘤长径和淋巴节短径） 长径：就是最长的，后期不需要和基线用一个方向量 空洞：测量方法不变，测壳，不需要绕开空洞，要标记空洞。内部坏死，有气体或液体 靶病灶只要选做基线了就一直算，就算肿瘤小于10或淋巴节小于15 有淋巴节，CR的时候直径和不一定是0 肿瘤如果看不清 大概率消失：0mm 还在但太浅测不准：5mm，层厚多少都是5mm 很小但是能测：实际值，比如2mm 分裂 每个分出来的部分当作一个靶病灶 融合 如果还有界线，分别测 如果界线不清，当成一个靶病灶 非靶病灶记存在，缺失，明确进展 明确进展 尽管靶病灶是SD或PR，但是非靶病灶已经恶化到提示应该终止治疗了 Resist Complete Response 所有病灶消失（靶病灶和非靶病灶） 所有淋巴节短径 $\\le$ 10mm Partial Response：和基线直径和相比减少30%以上 Progressive Disease 和之前所有直径和中最小的相比增加20%以上（和最小的而不是基线比） 增加的值要大于5mm（已经很小容易误差） 出现一个或多个新病灶：只要出现新病灶就是PD 只要是新病灶，不管能不能测量都算 新病灶刚出现的时候不好判断是不是肿瘤相关，如果通过后期扫描判断肿瘤相关，PD时间算发现新病灶的时间，不是确定新病灶是肿瘤相关的时间 非靶病灶出现明确进展 Stable Disease：减小不够PR，增加不够PD iResist 和Resist一样 iCR iPR iSD 额外细分 iuPD：unconfirmed Progressive Disease，对应Resist的PD，超进展 icPD：comfirmed Progressive Disease，iuPD4～6周后还是PD，确实PD了 可以综合主观感受进行评判 " }, { "title": "图像处理笔记", "url": "/posts/Image-Video-Processing/", "categories": "Note, Video Image Processing", "tags": "Note, Video Image Processing", "date": "2022-02-13 01:04:00 +0800", "snippet": " Rod：视杆，亮度，120M Cone：视椎，颜色，6M颜色表示 三元色：Trichromatic color mixing RGB 波长：R&amp;gt;G&amp;gt;B，紫外线波长小，能量大，杀菌 CMY cyan：青 magenta：品红 yellow XYZ Y：亮度 XZ：颜色 亮度+颜色 Luminance 亮度 Chrominance 色度 Hue：色调，色轮上的角度 $\\theta$，颜色的主导波长，渐变的 Saturation：饱和度，有多纯，掺了多少白。越纯越饱和，白色最不饱和 CIELAB 一些颜色需要负的红 HSI(HSB) YIQ：模拟，NTSC(National Television SystemCommittee)美国标准 Y亮度 IQ颜色 模拟彩电颜色标准，黑白电视只放YIQ里的Y YUV：模拟，PAL欧洲标准 YCbCr：数字版YUV 很多压缩图像用这个格式 RBG-&amp;gt;Y：彩色变黑白 颜色范围 SDR：Standard Dynamic Range，8 bit HDR：High dynamic range，16 bit Illuminating source 发光频率决定颜色 R+G+B=White 一般用RGB Reflecting source 颜色=照射频率-吸收频率 R+B+G=Black 一般用CMY CMYK：Cyan(青), Magenta(洋红), Yellow(黄), Black(黑) 传感器上RGB交替4：demosaic颜色校准：白色的RGB要相等Gamma Correction：显示的强度和真实的强度是非线性的视频 Standard Definition：720x480，4：2，25-30fps，隔行或逐行扫描，8 bit High Definition，1080p，2K：1920x1080，16：9/2：1，最高60fps Ultra High Definition，4K：3840x2160，16：9，最高120fps，16 bit，发行10～12bit，色域更广对比度低对比度的图像看起来颜色非常贴近，理想图像颜色在直方图里分布宽且均匀直方图只能总结图像强度分布，很不一样的图片也可以有一样的直方图增强对比度逐个像素改变强度值，函数非递减 固定函数 线性拉伸 分段线性 非线性拉伸 Log变换：往上弯，拉伸暗区域 g = blog(af+1) 指数变换：往下弯，拉伸亮区域 $g = b(e^{af}-1)$ 指数变换，Power law 只能拉伸一头，集中中间的处理不了 自适应变换：根据原图和目标的直方图确定函数 直方图增强 原像素变成累积概率分布*最大强度，总能得到一个比较平的histogram 局部增强：图像整体强度分布平均，但是局部不平均，可以滑动窗口针对局部增强对比度在一些不重叠的区域里计算变换函数 区域里的所有像素用这个函数 区域边缘会有跳变 其他的位置向区域中心点距离加权平均傅立叶变换f(m,n)可分：函数可以表示为两个函数积 $f(m,n)=f_v(m)f_h(n)$，2D矩阵可以表示为两个1D矩阵积(没一行都成比例，每一列都成比例)函数内积，投影：一个函数乘另一个函数的共扼在整个定义域上积分$\\phi(x,idx)$ 第idx个基底。orthonormal：单位，垂直\\(\\int_{-\\infty}^\\infty \\phi(x, u_1)\\phi^*(x,u_2)dx=\\{\\begin{matrix}1, \\quad u_1=u_2 \\\\0, \\quad u_1\\ne u_2\\end{matrix}\\)正变换逆变换用的是 $2\\pi u$ 而不是 $\\omega$ ，所以没有 $\\frac{1}{2\\pi}$时域宽，低频信号多，频域窄。时域越宽越接近常数的频率0，频域越接近冲击。频域零点在1/时域方波长度(连续是1/2时域零点，离散是1/N，离散从0开始)时域卷积，频域相乘时域是实函数，频域性质2D傅立叶1D单位正交基底相乘得到的2D基底还是单位正交的2D信号频率 两个垂直方向的频率：比如x和y方向上单位长度(整幅图)分别 $f_x, f_y$ 周期 频率和角度：角度是频率最高的方向 $atan(\\frac{y}{x})$，这个方向上的频率 $f_m$ 是 $\\sqrt{f_x^2+f_y^2}$$F{f(x)}=\\frac{1}{2j}(\\delta(u-f_x,v-f_y)-\\delta(u+f_x, v+f_y))$可分2D傅立叶：如果f(x, y)可以表示为g(x)*h(y)的形式，用g(x)傅立叶得F(u)，用h(y)傅立叶得F(v)，F(u, v)=F(u)乘F(v)2D傅立叶旋转：空间可频域一起转DSFT, DFT空间内直线在dft里垂直方向会有一条亮线，用所有的频率做一条直线出来有周期的会有亮点；亮线和图像线垂直；很规整的sinc，比较发散卷积2D卷积两个坐标轴翻转，到第三象限滤波器：h(m,n) 一个系统的冲击反馈（point spread function）point spread function：一个点的输入一般result in一个区域，point spread越小分辨率越高 图像M*N，filter K*L，输出 M+N-1， K+L-1 图像M*N，filter (2k+1, 2k+1)，蓝色和橙色区域取决于padding可分滤波器可以在x，y上单独做采样&amp;amp;插值 采样：连续到离散 插值：离散到连续符号 采样间隔：$\\Delta_x$，$\\Delta_y$ 采样频率：$f_{s,x}=\\frac{1}{\\Delta_x}$，$f_{s,y}=\\frac{1}{\\Delta_y}$，时间维度的采样率fps nyquist频率：$f_{m,x}$，$f_{m,x}$，采样频率的一半 连续图像：$f(x, y)$ 采样图像：$f_s(m, n)$ 重建图像：$\\hat{f}(x, y)$ 采样 采样频率大于1/2信号最大频率 时域乘脉冲序列，间隔 $1/\\Delta$，幅度1 频域卷脉冲序列，间隔 $\\Delta$，幅度 $\\frac{1}{\\Delta_x\\Delta_y}$ 脉冲序列傅立叶还是脉冲序列 通过加频域的多个信号返回时域信号，频域信号的幅度小 重建 频域乘低通，截止频率 = 1/2采样频率，幅度 $\\Delta_x\\Delta_y$ 时域和sinc卷积 把sinc放在每一个像素上，幅度是像素强度，最后求和 采样图像里m，n对重建图像x，y的贡献权重是2d sinc在x,y和m，n距离位置的取值 采样：采样结果M行N列\\(f_s(m, n)=f(m\\Delta_x, n\\Delta_y) \\quad m=0,1,...,M, \\quad n=0,1,...,N \\\\\\)脉冲序列：\\(\\begin{aligned}p(x, y)&amp;amp;=\\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} \\delta\\left(x-m \\Delta_{x}, y-n \\Delta_{y}\\right)\\\\\\end{aligned}\\)脉冲序列的傅立叶： 1D：采样结果长度为N\\[\\begin{aligned}&amp;amp;p(t)=\\sum_{n=0}^{N-1} \\delta(t-n \\Delta t) \\Leftrightarrow P(u)=\\frac{1}{\\Delta t} \\sum_{n=0}^{N-1} \\delta(u-nf_s) \\\\&amp;amp;\\text { where } f_{s}=\\frac{1}{\\Delta t}\\end{aligned}\\]频率是 $f_s$，所以频率是 $f_s$ 整数倍的都过采样点 2D\\[\\begin{aligned}&amp;amp;p(x, y)=\\sum_{m, n} \\delta(x-m \\Delta x, y-n \\Delta y) \\Leftrightarrow P(u, v)=\\frac{1}{\\Delta x \\Delta y} \\sum_{m, n} \\delta\\left(u-m f_{s, x}, v-n f_{s, y}\\right) \\\\&amp;amp;\\text { where } f_{s, x}=\\frac{1}{\\Delta x}， f_{s, y}=\\frac{1}{\\Delta y}\\end{aligned}\\] 采样时域：信号 $\\times$ 脉冲序列\\(\\begin{aligned}\\tilde{f_{s}}(x, y)&amp;amp;=f(x, y) \\times p(x, y)\\\\&amp;amp;=\\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f\\left(m \\Delta_{x}, n \\Delta_{y}\\right) \\delta\\left(x-m \\Delta_{x}, y-n \\Delta_{y}\\right) \\\\&amp;amp;=\\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f_{s}(m, n) \\delta\\left(x-m \\Delta_{x}, y-n \\Delta_{y}\\right) \\\\\\end{aligned}\\) 采样频域：信号 * impulse train\\(\\begin{aligned}F_{s}(u, v)&amp;amp;=F(u, v) * P(u, v) \\\\P(u, v)&amp;amp;=\\frac{1}{\\Delta x \\Delta y} \\sum_{m, n} \\delta\\left(u-m f_{s, x}, v-n f_{s, y}\\right) \\\\\\Rightarrow F_{s}(u, v)&amp;amp;=\\frac{1}{\\Delta x \\Delta y} \\sum_{m, n} F\\left(u-m f_{s, x}, v-n f_{s, y}\\right) \\\\&amp;amp;\\text { where } f_{s, x}=\\frac{1}{\\Delta x}, f_{s, y}=\\frac{1}{\\Delta y}\\\\\\end{aligned}\\)这里如果采样频率不大于固有频率的二倍，频域信号就会有重合，就会有伪影 重建时域：采样信号 * 2d sinc$$\\begin{aligned}H(u, v)&amp;amp;=\\left{\\begin{array}{cc}\\Delta x \\Delta y &amp;amp; |u| \\leq \\frac{f_{s, x}}{2},|v| \\leq \\frac{f_{s, y}}{2} &amp;amp; 0 \\quad \\text { otherwise }\\end{array} \\Leftrightarrow h(x, y)=\\frac{\\sin \\pi f_{s, x} x}{\\pi f_{s, x} x} \\cdot \\frac{\\sin \\pi f_{s, y} y}{\\pi f_{s, y} y}\\right.\\\\hat{f}(x, y)&amp;amp;=\\tilde{f}{s}(x, y) * h(x, y) &amp;amp;=\\sum{m=0}^{M-1} \\sum_{n=0}^{N-1} f_{s}(m, n) \\delta\\left(x-m \\Delta_{x}, y-n \\Delta_{y}\\right) * h(x, y) &amp;amp;=\\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f_{s}(m, n)h\\left(x-m \\Delta_{x}, y-n \\Delta_{y}\\right) h(x, y)&amp;amp;=\\frac{\\sin \\left(\\pi f_{s, x} x\\right)}{\\pi f_{s, x} x} \\frac{\\sin \\left(\\pi f_{s, y} y\\right)}{\\pi f_{s, y} y} \\hat{f}(x, y)&amp;amp;=\\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f_{s}(m, n) \\frac{\\sin \\pi f_{s, x}(x-m \\Delta x)}{\\pi f_{s, x}(x-m \\Delta x)} \\frac{\\sin \\pi f_{s, y}(y-m \\Delta y)}{\\pi f_{s, y}(y-m \\Delta y)}\\end{aligned}$$$采样率低\\to空间间隔大\\to频域间隔小\\to和冲击卷完有叠加\\to采样完图像里能看到比原图周期低的信号\\to伪影\\to重建信号比原信号频率低$采样的频率应该大于信号固有频率的2倍，一个周期至少2个点x采样率够，y采样率不够jaggie插值滤波不可能是理想低通，那样空间域无限大。Nyquist filter 性质： 低通：超过采样频率一半的信号都是重复的 递减：离一个点越远，对这个点插值的贡献应该越小 偶函数 可分： $h(x,y)=h_v(x) \\cdot h_h(y)$，减少计算 $h(0,0)=1$, $h(m\\Delta_x, n\\Delta_y)=0$：采样值原样进入重建图像prefilter，sampling filter：实际图像里可能包含非常高频的信号，在采样之前先过一个截止频率 $f_c=\\frac{f_s}{2}$ 的滤波器。不做prefilter可以保留更多细节，但是会有低频的纹理 aliasing：采样前滤波带来的问题。原信号经过prefilter还是有高频信号，带来比1/2采样频率低的噪声。体现在直的线变阶梯，条纹有比原来频率低的。 imaging：插值的滤波器带来的问题。不是理想低通，截止频率之外还是有信号，带来比1/2采样频率高的噪声相机 相邻两个同颜色传感器中心的距离是采样间隔 传感器的输出是一个面积上的光强总数，相当于采样前滤波去掉高频信号aliasing 例子 https://www.red.com/red-101/cinema-temporal-aliasing观察的时候眼睛和脑子做插值的低通滤波角频率：看的时候重要的是单位角度的频率 屏幕越远频率越高 屏幕越大频率越低\\[\\begin{aligned}&amp;amp;\\theta=2 \\arctan (h / 2 d)(\\operatorname{radian}) \\approx 2 \\mathrm{~h} / 2 \\mathrm{~d}(\\operatorname{radian})=\\frac{180}{\\pi} \\frac{h}{d}(\\text { degree }) \\\\&amp;amp;\\mathrm{f}_{\\theta}=\\frac{\\mathrm{f}_{s}}{\\theta}=\\frac{\\pi}{180} \\frac{d}{h} \\mathrm{f}_{s}(\\text { cycle/degree })\\end{aligned}\\] 时间上通常能看到60hz，实际可以更快因为眼睛会跟着物体动，相对频率变小。显示60hz的信号需要120hz的采样率。 空间上通常能看到30 cycle per degree，空间上应该捕捉到60 cycle per degree 时间上频率越高，空间上同样角频率的信号越不敏感。时间快的场景分辨率就可以低 亮度越高，能分辨的帧率越高眼睛对亮度更敏感，4个Y不需要4个cbcr下采样周期变短，频率变高，可能会alias，下采样前先过一个half band filter，cutoff频率应该是固有频率1/4upsample：填0，卷积\\(\\begin{aligned}&amp;amp;\\tilde{f}(m, n)=\\left\\{\\begin{array}{cc}f(m / K, n / K) &amp;amp; \\text { if } m, n \\text { are multiple of } K \\\\0 &amp;amp; \\text { otherwise }\\end{array}\\right. \\\\&amp;amp;f_{u}(k, l)=\\sum_{k, l} \\tilde{f}(m, n) h(k-m, l-n)=\\tilde{f}(k, l) * h(k, l)\\end{aligned}\\) nearest neighbor：新值取决于跟原图里哪个像素最近 $\\mathrm{O}\\left[\\mathrm{m}^{\\prime}, \\mathrm{n}^{\\prime}\\right]=\\mathrm{I}[(\\text { int })(\\mathrm{m}+0.5),(\\text { int })(\\mathrm{n}+0.5)], \\mathrm{m}=\\mathrm{m}^{\\prime} / \\mathrm{M}, \\mathrm{n}=\\mathrm{n}^{\\prime} / \\mathrm{M}$ bilinear 双线性内插值：新值用原图里最近的四个点线性加权平均 分开插值 比如先沿行算整行算新点的所在的列应该是多少F[m,n’]=(1-a)I[m,n]+aI[m,n+1], a=n’-n. 之后再沿整列算新点所在的行应该是多少O[m’,n’]=(1-b)F[m’,n]+bF[m’+1,n], b=m’-m 整体插值 每个点的权重是新点和对角点组成矩形的面积O[m’,n’]=(1-a)(1-b)I[m,n]+a(1-b)I[m,n+1]+(1-a)bI[m+1,n]+abI[m+1,n+1] bicubic 双三次插值：新值用原图里最近16个点线性加权平均，系数里最高是a和b的立方$$\\begin{aligned}F\\left[m^{\\prime}, n\\right] &amp;amp;=-b(1-b)^{2} I[m-1, n]+\\left(1-2 b^{2}+b^{3}\\right) I[m, n]+b\\left(1+b-b^{2}\\right) I[m+1, n]-b^{2}(1-b) I[m+2, n] \\quadm= (int) \\frac{m^{\\prime}}{M}, \\quad b=\\frac{m^{\\prime}}{M}-m \\O\\left[m^{\\prime}, n^{\\prime}\\right]&amp;amp;=-a(1-a)^{2} F\\left[m^{\\prime}, n-1\\right]+\\left(1-2 a^{2}+a^{3}\\right) F\\left[m^{\\prime}, n\\right]+a\\left(1+a-a^{2}\\right) F\\left[m^{\\prime}, n+1\\right]-a^{2}(1-a) F\\left[m^{\\prime}, n+2\\right],where n= (int) \\frac{n^{\\prime}}{M}, a=\\frac{n^{\\prime}}{M}-n\\end{aligned}$$上采样周期变长，频率变小，可能会引入高频信号，上采样之后过一个half band filterH hermission 转制+共扼rou d变换&amp;amp;压缩N维空间里的所有向量都可以用N个线性无关的基底变换得来。概念 内积：一个求共扼，和另一个对应位置相乘求和。几D都是，几D结果都是标量 $A=(a_0, a_1, …, a_N)，B=(b_0, b_1, …, b_N)，A\\cdot B=a_0b_0+a_1b_1+…+a_N*b_N$ $A\\cdot B=trace(AB^H)=trace(BA^H)$，trace是主对角线元素和，i,j相等的位置元素和 几何意义是投影 $A\\cdot B= A   B cos&amp;lt;A,B&amp;gt;$ 外积 //: # (TODO:) 单位正交基底：线性无关，都是单位长度，两两垂直 共轭转制：$X^H=(X^{*})^T$ hermitian 酉矩阵：单位正交列向量组成的矩阵，unitary matrix $酉矩阵^{-1}=酉矩阵^{H}$ 酉矩阵U：$U^H U=U U^H=I$ 符号 N维 $b_i$：一个基底，列向量 B：$[b_0, b_1, …, b_{N-1}]$。基底列向量组成的N*N矩阵，必须可逆 U：单位正交基底 通常排序从$b_0$到$b_{N-1}$ 频率越来越高 S：信号列向量 T：变换系数列向量，$S=B\\cdot T$ $E(\\mathbf{X})$： 期望。$\\mathbf{X}=(X_1, X_2, .., X_M)$， $E(\\mathbf{X})$ 是 $\\mathbf{X}$ 的期望，和 $\\mathbf{X}$ 里的一个 $X$ 一样大 $Var(\\mathbf{X})$：方差。$\\sum {X-E(\\mathbf{X})}\\cdot{X-E(\\mathbf{X})}^H$。每个$X$和所有$X$期望做差，这个差和自己的hermission乘，求和。结果和$X$一样大\\(b_i = \\begin{bmatrix}b_{i,0} \\\\b_{i,1} \\\\.\\\\.\\\\.\\\\b_{i,N-1} \\\\\\end{bmatrix}，B=[b_0, b_1, ... , b_{N-1}] \\\\T = \\begin{bmatrix}t_0 \\\\t_1 \\\\.\\\\.\\\\.\\\\t_{N-1}\\end{bmatrix} \\\\S = \\begin{bmatrix}s_0 \\\\s_1 \\\\.\\\\.\\\\.\\\\s_{N-1}\\end{bmatrix} \\\\\\) 逆变：变换系数 $\\rightarrow$ 信号，合成 信号在每个基底上的分量乘那个基底，横向做和\\(S=BT\\) 正变：信号 $\\rightarrow$ 变换系数，分解\\(T=B^{-1}S\\) 对单位正交基底$U$，$U^{-1}=(U^*)^T$，记为$U^{H}$\\(T=U^{-1}S=U^{H}S\\) 变换理解：在单位正交基底U上 正变：$T=U^HS$ $U^H$中第k行是第k个基底$u_k$的共轭 矩阵相乘的时候，$U^H$第k行和信号对应位置相乘求和 就是 $u_k^*$ 和信号对应位置相乘求和 就是 $u_k\\cdot S$ 就是信号在 $u_k$ 上的投影 逆变：$S=UT$ T中的第k个数是信号在第k个基底上的投影 U的第k列是第k个基底 UT可以看作U的第k列先乘T的第k个数，得到k个列矩阵之后再每行平均 一些变换 Hadmard\\(\\begin{aligned}&amp;amp;\\mathbf{h}_{0}=\\left[\\begin{array}{l}1 / 2 \\\\1 / 2 \\\\1 / 2 \\\\1 / 2\\end{array}\\right], \\mathbf{h}_{1}=\\left[\\begin{array}{c}1 / 2 \\\\1 / 2 \\\\-1 / 2 \\\\-1 / 2\\end{array}\\right], \\mathbf{h}_{2}=\\left[\\begin{array}{c}1 / 2 \\\\-1 / 2 \\\\-1 / 2 \\\\1 / 2\\end{array}\\right], \\mathbf{h}_{3}=\\left[\\begin{array}{c}1 / 2 \\\\-1 / 2 \\\\1 / 2 \\\\-1 / 2\\end{array}\\right] \\\\&amp;amp;\\mathbf{f}=\\left[\\begin{array}{l}1 \\\\2 \\\\3 \\\\4\\end{array}\\right] \\Rightarrow\\left\\{\\begin{array}{l}t_{0}=5 \\\\t_{1}=-2 \\\\t_{2}=0 \\\\t_{3}=-1\\end{array}\\right.\\end{aligned}\\) 离散傅立叶 DFT：第k个基底的频率是k圈，从一圈里采样N个点\\(\\begin{aligned}&amp;amp;F(k)=\\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} f(n) e^{-j 2 \\pi \\frac{k n}{N}}, \\quad k=0,1, \\ldots, N-1 \\\\&amp;amp;f(n)=\\frac{1}{\\sqrt{N}} \\sum_{k=0}^{N-1} F(k) e^{j 2 \\pi \\frac{k n}{N}}, \\quad n=0,1, \\ldots, N-1\\end{aligned}\\) \\[\\begin{aligned}&amp;amp;h_{k}(n)=\\frac{1}{\\sqrt{N}} e^{j 2 \\pi \\frac{k n}{N}}, \\quad \\text { or } \\\\&amp;amp;\\mathbf{h}_{k}=\\frac{1}{\\sqrt{N}}\\left[\\begin{array}{c}1 \\\\e^{j 2 \\pi \\frac{k}{N}} \\\\\\vdots \\\\\\left.e^{j 2 \\pi \\frac{(N-1) k}{N}}\\right]\\end{array}\\right], k=0,1, \\ldots, N-1\\end{aligned}\\] 离散余弦变换 DCT\\(\\begin{aligned}&amp;amp;h_{k}(n)=\\alpha(k) \\cos \\left[\\frac{(2 n+1) k \\pi}{2 N}\\right] \\\\&amp;amp;\\text { where } \\alpha(k)= \\begin{cases}\\sqrt{1 / N} &amp;amp; k=0 \\\\\\sqrt{2 / N} &amp;amp; k=1, \\ldots, N-1\\end{cases}\\end{aligned}\\)\\(T(k)=\\sum_{n=0}^{N-1} f(n) h_{k}(n) \\\\f(n)=\\sum_{u=0}^{N-1} T(k) h_{k}(n)\\)//: # (TODO:整理符号)单位正交变换的统计性质 $t_0=Avg(S)$ 第一个基底$u_0$是单位长度，并且所有分量相等。$t_0$就是整个信号S的平均数 $U^HE(\\mathbf{S})=E(\\mathbf{T})，UE(\\mathbf{T})=E(\\mathbf{S})$ 多个信号经过正变得多个系数，信号们的均值 $E(\\mathbf{S})$ 和系数们的均值 $E(\\mathbf{T})$ 和一个基底都一样大 系数的期望就是样本的期望分解，样本的期望就是系数的期望合成 $U^HVar(\\mathbf{S})U=Var(\\mathbf{T})，UVar(\\mathbf{T})U^H=Var(\\mathbf{S})$ $X$ 是N维向量，$Var(\\mathbf{X})$ 是N*N维向量，$Var(\\mathbf{X})[i,j]$ 代表一堆 $X$，就是 $\\mathbf{X}$ 中第i个维度和第j个维度的相关性 信号的方差先投影到各个基底上，得到信号的方差在各个基底上的系数，之后合成系数的方差；系数的方差先合成一个信号，得到每个系数对每个系数方差的信号，之后投影到各个基底上得到信号的方差 样本的方差就是系数的方差先合成再右乘$U^H$，系数的方差就是样本的方差先分解再右乘$U$ 一组好的基底系数的方差应该尽可能对角&amp;lt;!– - $Var(\\mathbf{S})[i, j]$ 是信号第i维度和第j维度间的方差，这个矩阵的第j列是各个维度和第j个维度间的方差 定义 $P=U^HVar(S)$ ，P的第j列是 $Var(\\mathbf{S})$ 中的第j列分别和每个基底做内积得来。所以P的第j列就是信号各个维度和第j个维度间的方差在各个基底上的投影 P[a,j]是信号各个维度和第j个维度间的方差在第a个基底上的投影 P中的第a行是信号各个维度和各个维度的方差在第a个基底上的投影 最后 PU[a,b] 是P的第a行和U的第b列对应位置相乘求和，是把信号的方差在第a个基底上的投影和第b个基底按位置相乘， –&amp;gt;//: # (TODO:左乘和右乘的含义) 单位正交基底，信号平方和跟系数平方和相同；非单位正交基底，所有信号内的方差和所有系数内的方差和相同 平方是 $\\sqrt{(x \\times x^*)}$ 丢掉一些高频分量，信号每个维度误差的平方和=丢掉的分量的系数平方和 比如对基底和信号\\(\\begin{aligned}&amp;amp;\\mathbf{h}_{0}=\\left[\\begin{array}{l}1 / 2 \\\\1 / 2 \\\\1 / 2 \\\\1 / 2\\end{array}\\right], \\mathbf{h}_{1}=\\left[\\begin{array}{c}1 / 2 \\\\1 / 2 \\\\-1 / 2 \\\\-1 / 2\\end{array}\\right], \\mathbf{h}_{2}=\\left[\\begin{array}{c}1 / 2 \\\\-1 / 2 \\\\-1 / 2 \\\\1 / 2\\end{array}\\right], \\mathbf{h}_{3}=\\left[\\begin{array}{c}1 / 2 \\\\-1 / 2 \\\\1 / 2 \\\\-1 / 2\\end{array}\\right], \\\\&amp;amp;\\mathbf{f}=\\left[\\begin{array}{l}1 \\\\2 \\\\3 \\\\4\\end{array}\\right] \\Rightarrow\\left\\{\\begin{array}{l}t_{0}=5 \\\\t_{1}=-2 \\\\t_{2}=0 \\\\t_{3}=-1\\end{array}\\right.\\end{aligned}\\)信号和系数的平方和都是30。只用$h_0$和$h_1$\\(\\begin{gathered}\\hat{f}=t_{0} h_{0}+t_{1} h_{1}=\\frac{5}{2}\\left[\\begin{array}{l}1 \\\\1 \\\\1 \\\\1\\end{array}\\right]-\\frac{2}{2}\\left[\\begin{array}{c}1 \\\\1 \\\\-1 \\\\-1\\end{array}\\right]=\\frac{1}{2}\\left[\\begin{array}{l}3 \\\\3 \\\\7 \\\\7\\end{array}\\right], \\mathrm{e}=f-\\hat{f}=\\frac{1}{2}\\left[\\begin{array}{l}2 \\\\4 \\\\6 \\\\8\\end{array}\\right]-\\frac{1}{2}\\left[\\begin{array}{l}3 \\\\3 \\\\7 \\\\7\\end{array}\\right]=\\frac{1}{2}\\left[\\begin{array}{c}-1 \\\\1 \\\\-1 \\\\1\\end{array}\\right] \\\\||e||^2=1, t_{2}^{2}+t_{3}^{2}=1\\end{gathered}\\)e的平方和跟没用的两个系数的平方和都是1 2D可分离基底：一套2D基底由一套1D基底矩阵相乘$h_ah_b^T$或者向量外积得来 不是单个基底是可分矩阵，是用一套1D基底$h_ah_b^T$生成一套2D基底 2D单位正交基底：和自己内积和都是1，和别人内积和都是0\\[\\begin{aligned}\\mathbf{h}_{0}=\\left[\\begin{array}{l}1 / \\sqrt{2} \\\\1 / \\sqrt{2}\\end{array}\\right], \\mathbf{h}_{1}=\\left[\\begin{array}{c}1 / \\sqrt{2} \\\\-1 / \\sqrt{2}\\end{array}\\right] &amp;amp; \\\\\\mathbf{H}_{00}=\\mathbf{h}_{0} \\mathbf{h}_{0}^{T}=\\left[\\begin{array}{cc}1 / 2 &amp;amp; 1 / 2 \\\\1 / 2 &amp;amp; 1 / 2\\end{array}\\right] &amp;amp; \\mathbf{H}_{01}=\\mathbf{h}_{0} \\mathbf{h}_{1}^{T}=\\left[\\begin{array}{cc}1 / 2 &amp;amp; -1 / 2 \\\\1 / 2 &amp;amp; -1 / 2\\end{array}\\right] \\\\\\mathbf{H}_{10}=\\mathbf{h}_{1} \\mathbf{h}_{0}^{T}=\\left[\\begin{array}{cc}1 / 2 &amp;amp; 1 / 2 \\\\-1 / 2 &amp;amp; -1 / 2\\end{array}\\right] &amp;amp; \\mathbf{H}_{11}=\\mathbf{h}_{1} \\mathbf{h}_{1}^{T}=\\left[\\begin{array}{cc}1 / 2 &amp;amp; -1 / 2 \\\\-1 / 2 &amp;amp; 1 / 2\\end{array}\\right]\\end{aligned}\\]2D DCT基底2D hadamard 基底：只有0，1，没有DCT细，但是只需要做加法计算量 不可分：$N^4$ $N^2$个基底，每个基底内积$N^2$次乘法 可分：$2N^3$ 每行做1D变换，得到N个中间结果。一行$N$次乘法，每个图$N^2$，一共N个1D基底，总共$N^3$次乘法 对每个中间结果每列做1D变换，得到$N^2$个最终结果。也是$N^3$次乘法 按照zig-zag顺序频率变高，低频信号的方差大，变化更多。只保留低频分量重建误差小扔掉了高频分量，斜线变得台阶最好的变换基底好的变换基底 系数相关性小 能量集中：系数里少量大的，其他都接近0 计算简单：2D会选比较小的维度，否则计算量很大 2D可分离用于 压缩 降低特征维度 降噪KLT变换信号相关，基底是信号协方差矩阵的正交特征矢量。系数就是特征值PCA变换编码流程量化编码 定长 变长：出现的越多，编码越短比特率：每个情况的概率编码这个情况的bit数信息熵：$H(f)=-\\sum_k p(k)log_2p(k)$，每个概率$log_2(概率)$的和的相反数。信息熵是编码这个概率分布最少需要的bit数K=2 概率[1,0], [0,1]的信息熵是0 概率分布越平均，信息熵越大，[0.5, 0.5]最大，信息熵是1从概率最低的两个开始，合并成一个情况，合并后的概率是这两个的和，一个给1，一个给0。反复，页节点给1，子树给0。有时候两个情况经常固定顺序出现，这样编码连续的两个值，$K^2$种情况可能比编码K种情况比特率低JPEGJPEG 所有值-128 8*8 DCT DC信号 值是基于前一格推测这一格DC的误差（比如推测相等），不是实际的DC值 编码两部分：（定长编码方法，定长编码下的位置） 量化 低频信号量化间隔小，高频信号量化间隔大 不是朝着MSE优化，是要看起来更好 间隔是人看不同图片试出来的 行程长度压缩，每个非0值存（和前一个非0值之间多少个0，具体值） 在所有行程长度对上进行编码 huffman：有默认huffman编码表，也可以在图片里带 算数编码：压缩率高，计算复杂 除了整体出现频率以外，空间位置上的条件概率也是信息，跟DC一样先推测再记录错误 原图DCT系数量化结果行程长度压缩，顺序是zigzag，先右后下。不是按照行列！ 黑白图 bpp：bit pre pixel 调量化间隔控制比特率 彩色 可以每个channel按黑白处理 一起处理 转换成YCbCr CbCr下采样 一个16*16块6个块，4 Y，1 Cb，1 Cr 三个channel DCT参数分布不同，可以给不用的编码表 原图3*8bpp JPEG-LS：无损压缩或基本无损 JPEG2000：波长变换，无损金字塔 冗余表示，增加 $\\frac{1}{3}N^2$ 数据量 不断下采样 采样结果是高斯 用下采样结果推测原尺度，推测和原尺度的參差是拉普拉斯 上：高斯金字塔 下：拉普拉斯金字塔，接近0的值很多用途 SIFT：抽取不同大小的同一特征 多尺度特征提取和检测 在高层抽象上计算更快 降噪：去掉高层（大图）拉普拉斯图像高频特征 压缩 更自然的图像融合小波分析 不冗余 方便重建小图：收到一个尺度就可以重建到一个尺度 在整个图像上进行变换，没有块状伪影Harr小波分析$h 0$ : averaging, $[1,1] / \\sqrt{2} ; \\quad h 1$ : difference, $[1,-1] / \\sqrt{2}$;\\(g 0=[1,1] / \\sqrt{2} ; \\quad g 1=[-1,1] / \\sqrt{2}\\) 低频：平均 高频：做差行列分别进行，一个阶段包含一次行一次列，出四张图。多阶段继续分析LL降噪" }, { "title": "机器学习笔记", "url": "/posts/ML/", "categories": "Note, Machine Learning", "tags": "Note, Machine Learning", "date": "2022-02-12 02:54:00 +0800", "snippet": "线性回归 很多自然现象是线性关系 一个非线性关系在很小的范围内也可以用线性关系描述：切线 对高斯随机的关系线性模型可以表示所有的参数 计算简单，容易理解单参数输出由一个输入决定符号 $\\bar{x}$：平均值 $s_{x}^2=s_{xx}$：方差 $s_{x}=\\sqrt{s_{xx}}$：标准差 $s_{xy}$：协方差\\[\\begin{align}y_i&amp;amp;=\\beta_{0}+\\beta_{1}x_i+\\epsilon \\\\y_i &amp;amp;\\approx \\hat{y}_i = \\beta_0 + \\beta_1 x_i \\\\\\epsilon_{i} &amp;amp;= y_{i}-\\hat{y}_{i}\\end{align}\\] RSS: $\\epsilon$ 平方和，不除N。Residual Sum of Square，Sum of Squared Residuals(SSR)，Sum of Squared Errors(SSE)。RSS是一个二次函数，凸函数只有一个最小值 MSE: Mean Square Error，除N Normalized MSE：$\\frac{MSE}{s_{y}^{2}}\\in[0,1]$凹凸是往下看，往下凸。凸函数convex，凹函数concave\\[RSS(\\beta_{0}, \\beta_{1})=\\sum_{i=1}^{N}(y_i-\\hat{y}_i)^2\\] MSE：Mean Square Error，$\\frac{1}{N}RSS$\\[MSE(\\beta_{0}, \\beta_{1})=\\frac{1}{N}RSS(\\beta_{0}, \\beta_{1}) =\\frac{1}{N}\\sum_{i=1}^{N}(y_i-\\hat{y}_i)^2\\] Least Square Fit：最小化RSS，点和直线的垂直距离平方和最小概率PMF：Probability Mass Function\\(PMF: P\\{x=x_i\\}=p_i\\)比如扔硬币，$P{x=0}=\\frac{1}{2}，P{x=1}=\\frac{1}{2}$\\[\\begin{aligned}E(x)&amp;amp;=\\sum_{i=1}^N x_i*p_i \\\\\\delta^{2}_x=\\operatorname{Var}(x)&amp;amp;=E(X-E(x))^{2} \\\\&amp;amp;=\\sum_{i=1}^{N}\\left(x_{i}-E(x)\\right)^{2} \\cdot p_{i} \\\\&amp;amp;=\\sum_{i=1}^N\\left[x_{i}^{2}-2 x_{i} E(x)+E(x)^{2}\\right) P_{i} \\\\&amp;amp;=\\sum_{i=1}^N x_{i}^{2} P_{i}-2 E(x) \\sum_{i=1}^N x_{i} P_{i}+E(x)^{2} \\sum_{i=1}^N p_{i} \\\\&amp;amp;=E\\left(x^{2}\\right)-2 E(x) \\cdot E(x)+E(x)^{2} \\\\&amp;amp; \\Rightarrow E\\left(x^{2}\\right)-E(x)^{2}\\\\E(x^2)&amp;amp;=Var(x)+E(x)^2\\\\E(ax+by)&amp;amp;=aE(x)+bE(y)\\end{aligned}\\]样本的均值就是样本的期望，不带偏见的期望\\(\\bar{x}=\\frac{1}{N}\\sum_{i=1}^N x_i \\\\E(\\frac{1}{N}\\sum_{i=1}^N x_i)=\\frac{1}{N}\\sum_{i=1}^N E(x_i)=E(x)\\)样本的方差约等于样本方差的期望，带偏见的期望。用了N个x计算均值和方差，方差的自由度不再是N而是N-1\\[s_{xx}=\\frac{1}{N}\\sum_{i=1}^N (x_i-\\bar{x})^2 \\\\E(\\sum_{i=1}^N (x_i-\\bar{x})^2) = (N-1)\\delta_x^2 \\\\E(s_{xx})=\\frac{N-1}{N}\\delta_x^2\\]不带偏见的方差，Bessel’s Correction\\(s_{xx}=\\frac{1}{N-1}\\sum_{i=1}^N (x_i-\\bar{x})^2 \\\\\\)算 $\\beta$ 均值\\(\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N}x_{i} \\\\\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N}y_{i} \\\\\\) xy协方差 covariance\\(s_{xy}=\\frac{1}{N}\\sum_{i=1}^{N}[(x_{i}-\\bar{x})*(y_{i}-\\bar{y})]\\) xy协方差是 $(x-\\bar{x})$ 和 $(y-\\bar{y})$ 两个向量的内积 x方差 variance\\(\\begin{align}s_{xx} &amp;amp;= s_{x}^2=\\frac{1}{N}\\sum_{i=1}^{N}(x_{i}-\\bar{x})^{2} \\\\s_{x} &amp;amp;= \\sqrt{s_{xx}}\\end{align}\\) y方差\\(\\begin{align}s_{yy} &amp;amp;= s_{y}^2=\\frac{1}{N}\\sum_{i=1}^{N}(y_{i}-\\bar{y})^{2} \\\\s_{y} &amp;amp;= \\sqrt{s_{yy}}\\end{align}\\) 方差 = 平方和平均值 - 平均值的平方\\(\\begin{align}s_{xx}&amp;amp;=\\frac{1}{N}\\sum_{i=1}^{N}(x_{i}-\\bar{x})^2\\\\&amp;amp;=\\frac{1}{N}\\sum_{i=1}^{N}(x_{i}^2-2x_{i}\\bar{x}+\\bar{x}^2)\\\\&amp;amp;=\\frac{1}{N}\\sum_{i=1}^{N} x_{i}^2 -2\\bar{x}\\frac{1}{N}\\sum_{i=1}^{N}{x_{i}} + \\bar{x}^2\\\\&amp;amp;=\\frac{1}{N}\\sum_{i=1}^{N} x_{i}^2 - \\bar{x}^2\\end{align}\\) x和y的关联系数\\(r_{xy}=\\frac{s_{xy}}{s_{x}s_{y}} \\in [-1, 1]\\)$s_x, s_y$ 是 $(x-\\bar{x}),(y-\\bar{y})$ 的长度根据柯西不等式 $s_{xy} = (x-\\bar{x}) * (y-\\bar{y}) *cos(x-\\bar{x},y-\\bar{y}) \\le s_{x}\\cdot s_{y}$ $r_{xy}^2$ 越接近1，x和y的关系越接近线性 平方误差\\(RSS(\\beta_{0}, \\beta{1})=\\sum_{i=1}^{N} (y_{i}-\\beta_{0}-\\beta_{1}x_{i})^2\\)二次函数是凸函数，所以导数为0的点RSS最小\\(\\begin{align}\\frac{\\partial RSS(\\beta_{0}, \\beta_{1})}{\\partial \\beta_{0}}&amp;amp;=\\sum_{i=1}^{N}2*(y_{i}-\\beta_{0}-\\beta_{1}x_{i})*-1 \\\\&amp;amp;=-2*\\sum_{i=1}^{N}\\epsilon_{i}\\\\\\Rightarrow \\sum_{i=1}^{N}\\epsilon_{i}&amp;amp;=0\\end{align}\\)一组好的 $\\beta$ 应该让线在所有点中间，往上和往下的误差相等\\(\\begin{align}\\frac{\\partial RSS(\\beta_{0}, \\beta_{1})}{\\partial \\beta_{1}} &amp;amp;= \\sum_{i=1}^{N}2*(y_{i}-\\beta_{0}-\\beta_{1}x_{i})*(-x_{i}) \\\\&amp;amp;=-2*\\sum_{i=1}^{N}\\epsilon_{i}*x_{i}&amp;amp;\\\\\\Rightarrow \\sum_{i=1}^{N}\\epsilon_{i}*x_{i}&amp;amp;=0 \\\\\\end{align}\\)$\\epsilon$ 和x的内积=0，说明误差应该和数据垂直\\(\\begin{align}&amp;amp;\\sum_{i=1}^{N}\\epsilon_{i}=0\\\\\\Rightarrow &amp;amp; \\sum_{i=1}^N(y_i-\\beta_0-\\beta_1x_i)=0 \\\\\\Rightarrow &amp;amp; \\sum_{i=1}^N y_i-N\\beta_0-\\beta_1\\sum_{i=1}^N x_i =0\\\\\\Rightarrow &amp;amp; N\\bar{y}-N\\beta_0-N\\beta_1\\bar{x} =0 \\\\\\Rightarrow &amp;amp; \\bar{y}=\\beta_0+\\beta_1\\bar{x}\\end{align}\\)模型的直线应该过均值点\\[\\begin{align}&amp;amp;\\sum_{i=1}^{N}x_i\\epsilon_i=0\\\\\\Rightarrow &amp;amp; \\sum_{i=1}^N x_i(y_i-\\beta_0-\\beta_1x_i)=0 \\\\\\Rightarrow &amp;amp; \\sum_{i=1}^N x_iy_i - x_i\\beta_0 -\\beta_1x_i^2 = 0\\\\\\Rightarrow &amp;amp; \\sum_{i=1}^N y_i-\\beta_0-\\beta_1x_i = 0 \\\\\\Rightarrow &amp;amp; \\sum_{i=1}^N y_i - \\bar{y} + \\beta_1\\bar{x}-\\beta_1x_i=0 \\\\\\Rightarrow &amp;amp; \\sum_{i=1}^N y_i - \\bar{y} = \\beta_1\\sum_{i=1}^N x_i-\\bar{x} \\\\\\Rightarrow &amp;amp; \\beta_1 = \\sum_{i=1}^N \\frac{y_i - \\bar{y}}{x_i-\\bar{x}} \\\\\\Rightarrow &amp;amp; \\beta_1 = \\sum_{i=1}^N \\frac{(y_i - \\bar{y})*(x_i-\\bar{x})}{(x_i-\\bar{x})*(x_i-\\bar{x})} \\\\\\Rightarrow &amp;amp; \\beta_1 = \\frac{s_{xy}}{s_{xx}} = \\frac{r_{xy}s_{y}}{s_{x}}\\\\\\end{align}\\]$\\frac{s_y}{s_x}$ 模型横向走过x的一个标准差，纵向走过y的一个标准差。模型的y和x越相关，斜率越大。\\[\\begin{aligned}\\beta_1 &amp;amp;= \\frac{s_{xy}}{s_{xx}}=\\frac{r_{xy}s_{y}}{s_{x}} \\\\\\quad \\beta_0 &amp;amp;= \\bar{y} - \\beta_1\\bar{x}\\end{aligned}\\]\\(\\begin{aligned}min RSS(\\beta_{0}, \\beta_{1})&amp;amp;=\\sum_{i=1}^N\\epsilon_i^2\\\\&amp;amp;=\\sum_{i=1}^N \\epsilon_i(y_i-\\beta_0-\\beta_1x_i)\\\\&amp;amp;=\\sum_{i=1}^N\\epsilon_iy_i - \\sum_{i=1}^N \\epsilon_i\\beta_0 - \\sum_{i=1}^N \\epsilon_i\\beta_1x_i\\\\&amp;amp;=\\sum_{i=1}^N\\epsilon_iy_i - \\beta_0\\sum_{i=1}^N \\epsilon_i - \\beta_1\\sum_{i=1}^N \\epsilon_ix_i\\\\&amp;amp;=\\sum_{i=1}^N\\epsilon_iy_i \\\\&amp;amp;=\\sum_{i=1}^N (y_i-\\beta_0-\\beta_1x_i)y_i\\\\&amp;amp;=\\sum_{i=1}^N y_i^2- \\sum_{i=1}^N\\beta_0y_i - \\sum_{i=1}^N\\beta_1x_iy_i\\\\&amp;amp;=N(\\bar{y^2} - \\beta_0\\bar{y}-\\beta_1\\bar{xy}) \\\\&amp;amp;=N(\\bar{y^2} - (\\bar{y} - \\beta_1\\bar{x})\\bar{y}-\\beta_1\\bar{xy}) \\\\&amp;amp;=N(\\bar{y^2} - \\bar{y}^2 + \\beta_1\\bar{x}\\bar{y}-\\beta_1\\bar{xy}) \\\\&amp;amp;=N(s_{yy} - \\beta_1s_{xy}) \\\\&amp;amp;=N(s_{yy} - \\frac{s_{xy}}{s_{xx}}s_{xy}) \\\\&amp;amp;=Ns_{yy}(1 - \\frac{s_{xy}^2}{s_{xx}s_{yy}}) \\\\&amp;amp;=Ns_{yy}(1-r_{xy}^2)\\end{aligned}\\)x，y非常相关的时候误差小；y越平越小。最终的误差跟怎么取x没有关系essense of linear algebra多参数多个输入决定输出符号 $x_i=(x_{i,1}, x_{i,2}, … , x_{i,k})$ $\\hat{y}i=\\beta{0} + \\beta_{1}x_{i,1} + … + \\beta_{k}x_{i,k}$\\[\\begin{align}A&amp;amp;=\\begin{bmatrix}1 &amp;amp; x_{1,1} &amp;amp; ... &amp;amp; x_{1,k} \\\\. &amp;amp; . &amp;amp; . &amp;amp; .\\\\. &amp;amp; . &amp;amp; . &amp;amp; .\\\\. &amp;amp; . &amp;amp; . &amp;amp; .\\\\1 &amp;amp; x_{N,1} &amp;amp; ... &amp;amp; x_{N,k}\\end{bmatrix} \\\\Y&amp;amp;=\\begin{bmatrix}y_{1} \\\\. \\\\. \\\\. \\\\y_{N}\\end{bmatrix} \\\\\\beta&amp;amp;=\\begin{bmatrix}\\beta_{0} \\\\\\beta_{1} \\\\. \\\\. \\\\. \\\\\\beta_{k}\\end{bmatrix} \\\\\\end{align}\\]\\[\\begin{align}Y \\approx \\hat{Y} &amp;amp;= A\\beta \\\\\\begin{bmatrix}y_{1} \\\\. \\\\. \\\\. \\\\y_{N}\\end{bmatrix}\\approx\\begin{bmatrix}\\hat{y}_{1} \\\\. \\\\. \\\\. \\\\\\hat{y}_{N}\\end{bmatrix}&amp;amp;=\\begin{bmatrix}1 &amp;amp; x_{1,1} &amp;amp; ... &amp;amp; x_{1,k} \\\\. &amp;amp; . &amp;amp; . &amp;amp; .\\\\. &amp;amp; . &amp;amp; . &amp;amp; .\\\\. &amp;amp; . &amp;amp; . &amp;amp; .\\\\1 &amp;amp; x_{N,1} &amp;amp; ... &amp;amp; x_{N,k}\\end{bmatrix} \\begin{bmatrix}\\beta_{0} \\\\\\beta_{1} \\\\. \\\\. \\\\. \\\\\\beta_{k}s\\end{bmatrix}\\end{align}\\]\\[\\begin{align}\\epsilon &amp;amp;= y-\\hat{y} \\\\RSS(\\beta)&amp;amp;=\\epsilon^{T}\\cdot\\epsilon=\\sum_{i=1}^N(y_i-\\hat{y}_i) \\\\MSE(\\beta)&amp;amp;=\\frac{1}{N}\\epsilon^{T}\\cdot\\epsilon \\\\NormalizedMSE&amp;amp;=\\frac{1}{N}\\frac{\\epsilon^{T}\\cdot\\epsilon}{s_{y}^{2}}\\in[0,1]\\end{align}\\]\\[\\beta=\\left( A^{T} A\\right)^{-1}\\left(A^{T} Y\\right) =P^{-1}r\\\\minRss(\\beta)=Y^{T}(I-A(A^{T}A)^{-1}A^{T})Y\\]$A^{T}A$ 是A的方差，对 $s_{xx}$；$A^{T}Y$ 是A和Y的关联，对 $s_{xy}$独热编码模型选择逻辑回归" }, { "title": "Arch常用软件", "url": "/posts/Arch-Apps/", "categories": "Linux, Arch", "tags": "Linux, Arch", "date": "2021-12-13 18:27:00 +0800", "snippet": "这篇记录一些 Arch Linux 常用的软件和设置，用于在安装完成后进行设置。btrfs如果用了 btrfs 可以考虑保留一个刚安装完系统的快照。这里默认子卷的结构按照安装教程。snapper 默认要用 dbus，如果还在 chroot 里需要重启进系统跑下面的命令。su rootpacman -S snapperumount /.snapshotsrm -rf /.snapshotssnapper -c root create-config /vim /etc/snapper/configs/root# ALLOW_USERS=&#39;[用户名]&#39;# todo 最后的期限限制chmod a+rx /.snapshots # 让所有用户对镜像都有读写权限systemctl start snapper-timeline.timersystemctl enable snapper-timeline.timersystemctl start snapper-cleanup.timersystemctl enable snapper-cleanup.timersystemctl start grub-btrfs.path # 开机grub里可以选重启到哪个快照systemctl enable grub-btrfs.pathsnapper -c root listsnapper -c root create --description BeforeGui快照会创建在/.snapshot 路径下，下面文件夹名字是这个快照的编号可以看到虽然快照下有 home 目录，/home 里面也有东西，但是快照里 home 是空的。全系统 rollback。Arch 推荐从启动盘进行全系统 rollback，首先重启进入启动盘mount /dev/[btrfs的任意一个分区] /mntless /mnt/@snapshots/*/info.xml # 查看所有镜像的信息# 下面需要删除当前的文件，可以把当前的文件mv到另一个地方，我一般直接删除# mv /mnt/@ /mnt/@.oldrm -rf /mnt/@btrfs subvol snapshot /mnt/@.snapshots/[要rollback到的snapshot编号]/snapshot /mnt/@reboot权限sudo 使用非常广泛，但是通常在个人电脑的场景下 sudo 的用途只是让一个用户可以作为 root 执行命令，就这个使用场景来说 sudo 比较杀鸡用牛刀。doas 不一定比 sudo 安全，但是精简很多su rootpacman -S opendoas# 允许 用户名 作为root执行命令，persist是一次输入密码之后一段时间内不会重新要密码echo &quot;permit persist [用户名] as root&quot; &amp;gt;&amp;gt; /etc/doas.conf# 用 doas 替换 sudomv /usr/bin/sudo /usr/bin/sudo-bkln -s /usr/bin/doas /usr/bin/sudoexitdoas ls # 测试配置是否正确如果一些程序依赖 sudo，用 doas 不行可以通过修改 /usr/bin/sudo 软链接或者直接重装 sudo 进行暂时恢复。包管理yayyay 是个很有用的包管理工具，使用方法跟 Arch 自带的 pacman 基本完全相同，主要是加入了对 AUR 的支持。在 AUR 里基本能找到所有常用的软件。下面的命令安装 yaycddoas pacman -Syyu # 全系统更新doas pacman -S git base-develgit clone https://aur.archlinux.org/yay.git # 下载yay代码cd yaymakepkg -si # 编译并安装yay # 更新所有的包，测试安装doas vim /etc/makepkg.conf # 把 PKGEXT .pkg.tar 后面的 .zst 或者 .xz 之类的后缀去掉，这样本地编译的包不需要压缩直接安装，快一些本地编译代码通常都需要 base-devel。如果从源码编译的过程中报一些类似缺少 fakeroot，build utils 之类的错，跑下面的命令装一下doas pacman -S base-devel基本用法，注意包名是区分大小写的，一般都是小写yay package_name # 不写 -S 的时候是进行搜索，从搜索结果中选具体装哪个yay -S pkg_name # 写 -S 和 pacman 一样是直接安装这个包yay -R pkg_name # 删除一个包yay -Q # 列出所有已安装的包yay -Q | grep pacma* # -Q应该是不支持通配符，用 grep 和 * 比较方便镜像测速全球有很多 pacman 软件库的镜像，选一个快的能节省不少下载时间。reflector 可以按速度对镜像排序，也可以定时执行doas pacman -S reflector rsync curldoas cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bakdoas reflector --latest 20 --country China --protocol https --sort rate --save /etc/pacman.d/mirrorlist一般镜像的速度不会变得很频繁，但是 reflector 也是可以定时更新镜像列表的。首先把参数写入配置文件echo &quot;&quot;&quot;--latest 20--country China--protocol https--sort rate--save /etc/pacman.d/mirrorlist&quot;&quot;&quot; | doas tee /etc/xdg/reflector/reflector.confdoas systemctl enable reflectordoas systemctl start reflector.timerdoas systemctl enable reflector.timer默认配置是每周执行一次，可以在配置文件里指定这个周期，比如把 OnCalendar 改成 daily，之后需要重新加载配置文件doas vim /usr/lib/systemd/system/reflector.timerdoas systemctl daemon-reloaddoas systemctl status reflector.timer # Trigger: 可以看到还有多久下次执行密码管理pass是一个不错的选择，加密基于 gpg，生态丰富，在不同平台和浏览器上都有 gui 或插件。yay -S pass # 密码管理工具yay -S qtpass # qt图形界面此外passff是一个在火狐系浏览器中进行自动填充的工具，需要安装火狐插件和一个本地 app。浏览器FirefoxLibreWolf 是基于 Firefox 开发的一个关注隐私保护的浏览器，用起来体验和 Firefox 差别不大。默认设置关浏览器就会清 cookie 所以网站会要求重新登陆，结合密码管理工具并不很影响使用体验。大多数 Firefox 的设置都是在的，可以根据自己的需要调整，比如保存浏览历史或者针对一些/所有网站关浏览器不清除 cookie。yay -S librewolf-binChromechromium 阵营的隐私浏览器 Brave 和 Vivaldi 貌似风评都不是很好，有一个开源的选择 ungoogled-chromium。缺点是貌似没有二进制的包，安装和更新都需要编译源码，在我的机器上编译花了 4 个半小时。(很神奇的是整个过程 CPU 8 个核都是 100%但是风扇一直没转 /笑哭 ) 而且 ungoogled-chromium 不是开箱就设置好的，大多数隐私保护设置都需要调，不是很方便。yay -S ungoogled-chromium中文输入法如果中文都显示成麻将那是缺少中文自体，在系统语言中添加中文doas vi /etc/locale.gen# 按 / 搜索，输入 zh_CN.UTF8 UTF8，回车找到这一行# 将这一行前面的 # 去掉# 输入 :wq 保存并退出doas locale-gen安装中文字体doas pacman -S noto-fonts-cjk安装 fcitx5doas pacman -Rs $(pacman -Qsq fcitx) # 删除已有fcitxdoas pacman -S fcitx5 fcitx5-gtk fcitx5-qt fcitx5-configtool fcitx5-chinese-addonsmkdir ~/.config/fcitx5修改 ~/.config/fcitx5/profile[Groups/0]# Group NameName=Default# LayoutDefault Layout=us# Default Input MethodDefaultIM=pinyin[Groups/0/Items/0]# NameName=keyboard-us# LayoutLayout=[Groups/0/Items/1]# NameName=pinyin# LayoutLayout=[GroupOrder]0=Default对于 wayland 图形系统，在 ~/.pam_environment 中添加GTK_IM_MODULE DEFAULT=fcitx5QT_IM_MODULE DEFAULT=fcitx5XMODIFIERS DEFAULT=@im=fcitx5对于 x 图形系统，在 ~/.xprofile 和 ~/.xinitrc中添加export XIM=&quot;fcitx5&quot;export XIM_PROGRAM=&quot;/usr/bin/fcitx5&quot;export GTK_IM_MODULE=&quot;fcitx5&quot;export QT_IM_MODULE=&quot;fcitx5&quot;export XMODIFIERS=&quot;@im=fcitx5&quot;export QT_QPA_PLATFORM=&quot;xcb&quot;export GDK_BACKEND=&quot;x11&quot;安装完成，启动 fcitx。可以在命令行输入xfce4-appfinder之后打 fcitx5，就可以启动。或者直接在命令行输入fcitx5声音Linux 的声音系统分两层，驱动和声音服务器(Sound Server)。驱动有两个选择，ALSA 和 OSS。ALSA Arch 安装自带，OSS 因为闭源过了一段时间整体上看赶不上 ALSA。doas pacman -S pulseaudio pavucontrolpulse audio 默认的配置在蓝牙设备连接之后不会自动切换到蓝牙设备，每次都需要打开 audio mixer 手动选。修改配置开启自动切换echo &quot;load-module module-switch-on-connect&quot; | doas tee -a /etc/pulse/default.pa重启 pulse audio 比较麻烦，可以登出一下重新进来。蓝牙doas pacman -Sy bluez bluez-utils bluemandoas systemctl start bluetooth.servicedoas systemctl enable bluetooth.serviceyay -S pulseaudio-bluetooth打开 bluetooth manager 会自动在面板上添加一个 widget。如果蓝牙是关闭状态搜索 bluetooth adapter 可以打开。jack 低延迟yay -S reaper-bin sws supercollider sc3-plugins jack2 mpv sox qjackctl pulseaudio-bluetooth pulseaudio-jack pulseaudio njconnect flac cadence alsa-firmware alsa-plugins alsa-utilsdoas pacman -S realtime-privilegesdoas groupadd realtimedoas usermod -a -G realtime $USERcat /proc/sys/vm/swappinessdoas sysctl vm.swappiness=10yay -S tuneddoas systemctl start tuned.service# Rule for when switching to batteryACTION==&quot;change&quot;, SUBSYSTEM==&quot;power_supply&quot;, ATTR{type}==&quot;Mains&quot;, ATTR{online}==&quot;0&quot; RUN+=&quot;/usr/bin/tuned-adm profile laptop-battery-powersave&quot;# Rule for when switching to ACACTION==&quot;change&quot;, SUBSYSTEM==&quot;power_supply&quot;, ATTR{type}==&quot;Mains&quot;, ATTR{online}==&quot;1&quot; RUN+=&quot;/usr/bin/tuned-adm profile latency-performance&quot;alias cpu-max=&#39;tuned-adm profile latency-performance&#39;alias cpu-balanced=&#39;tuned-adm profile balanced&#39;alias cpu-min=&#39;tuned-adm profile laptop-battery-powersave&#39;git clone https://codeberg.org/rtcqs/rtcqs.gitcd rtcqs./rtcqs.pydoas systemctl --user stop pulseaudio.socketdoas systemctl --user stop pulseaudio.servicedoas systemctl start tuned.servicedoas sysctl vm.swappiness=10cat /proc/sys/vm/swappinesscpu-maxdoas systemctl stop tuned.servicedoas systemctl --user start pulseaudio.socketdoas systemctl --user start pulseaudio.servicedoas sysctl vm.swappiness=60cat /proc/sys/vm/swappinesscpu-balancedshellzshdoas pacman -S zshsh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;快捷键在 app finder 里搜 keyboard 可以找到键盘设置，一些有用的快捷键xfce4-terminal --drop-down # 从屏幕顶部滑下来一个命令行，比较方便，一般可能会设成Alt + `xfce4-appfinder # 打开程序搜索thunar # 文件浏览器xkill # 强制关闭，对付卡死的窗口还有一个设置在 window manager 里，正常关闭一个窗口也比较有用软件百度网盘百度网盘有 deb 的包但是 debtap 过来跑不起来，这个包是 web 版的封装，有 4G 上传大小的限制。yay -S baidunetdisk-electron另一个选择是 baidupcs，个人感觉在 Arch Linux 上比官方客户端好用yay -S baidupcs微信deepin-wine-wechat 依赖 Multilib 里的一些 32 位库，Arch Linux 默认不搜索 Multilib，开了之后才能安装doas vim /etc/pacman.conf找到下面两行，把前面的 # 删掉#[multilib]#Include = /etc/pacman.d/mirrorlist之后更新本地仓库，安装微信yayyay -S deepin-wine-wechat # 之后一路回车选择默认就行在不用时间不同地点从腾讯下载微信可能得到的安装包不是完全相同的，通常哈希值校验失败不是大问题。下面这行安装可以跳过哈希校验yay -S --mflags --skipinteg deepin-wine-wechat腾讯会议是一个旧版本的腾讯会议 ubuntu 包，主要的缺点是不能接受别人在屏幕上标画，个人没有遇到其他使用上的问题。yay -S wemeet-bin压缩zipdoas pacman -S unzip zipconda从miniconda 官网下载对应的安装脚本，比如 x86 的机器安装脚本应该叫 Miniconda3-latest-Linux-x86_64.sh。之后进行安装bash [刚下载的安装脚本] 按照指引安装就行。“Do you wish the installer to initialize Miniconda3 by running conda init? [yes no]” 我会选 yes，启动比较方便。安装完成后需要退出当前的命令行重新开一个，看到 prompt 最前面有一个 (base) 就是安装成功了。 基本使用conda create -n [名字] python=3.9conda activate [名字]录屏yay -S simplescreenrecorder虚拟机安装 arch 之后没有一些腾讯会议之类的软件，可能偶尔会需要用一下 windows 虚拟机。做 Windows 虚拟机首先需要一个 Windows iso，可以从微软官网或msdn下。msdn 的 BT 链接可以先用百度网盘的离线下载下到网盘里，之后下到本地。host 这边选择用 qemu 做虚拟机，更新系统安装软件doas pacman -Syy# 如果更新linux内核版本了需要重启才能生效doas pacman -S archlinux-keyringdoas pacman -S qemu virt-manager virt-viewer dnsmasq vde2 bridge-utils openbsd-netcatdoas pacman -S ebtables iptablesdoas systemctl start libvirtd默认 virt-manager 可能需要 root 权限才能运行，修改 /etc/libvirt/libvirtd.conf，让他可以在用户权限下运行doas vi /etc/libvirt/libvirtd.conf# unix_sock_group = &quot;libvirt&quot;# unix_sock_rw_perms = &quot;0770&quot;newgrp libvirtdoas usermod -a -G libvirt $(whoami)之后打开 Virtual Machine Manager，按照提示一步一步安装即可。//: # (TODO:具体步骤截图)安装好 windows 后 host 和 client 的剪切板是不能共享的，有时候可能不太方便。可以在 windows 里装一个 spice-guest-tools，host 上不需要额外装软件就可以实现双向剪切板共享。下载地址： https://www.spice-space.org/download.html点那个 spice-guest-tools 下载，之后安装。如果只是偶尔在 host 和 guest 之间传个文件那可以用sharedrop.io这种局域网传文件的工具或者上网盘绕一圈。如果传的比较频繁可以考虑装一个 samba。windows 和 mac 都内置了对 samba 的支持，linux 的 host 需要安装和配置一下。doas pacman -S samba # 安装sambacd /etc/sambadoas vi smb.confarch 上安装 samba 不带默认的配置文件，打开这个官方的配置文件样例，粘到刚才 vi 的 smb.conf 里。按照下面格式在文件末尾添加一个网络共享[smbarch]comment = smbarchpath = /path/to/share # 这里一定要用绝对路径，相对的不行writable = yesbrowsable = yescreate mask = 0700directory mask = 0700read only = noguest ok = no默认配置给的 log 路径是没有写入权限的，找到 log file 这一行改成下面这个路径log file = /var/log/samba/%m.log最后添加 samba 用户组，创建要分享的目录并修改权限doas groupadd -r smbuserdoas usermod -aG smbuser $(whoami)doas smbpasswd -a linmkdir /path/to/sharedoas chown -R :smbuser ~/Desktop/samba/doas chmod 1770 ~/Desktop/samba/doas systemctl start smbdoas systemctl start nmb之后在 windows 中右键我的电脑，点添加网络位置，地址按照 //ip/smbarch 这个格式写。host 的 ip 可以用 ip a 查到，不是环回的 127.0.0.1，而且是一个局域网地址，比如 192.168. …这种添加成功后输入用户名密码就能看到文件了。手机用 usb 在 Arch 和 Android 之间传文件需要 MTP(Media Transfer Protocol)的支持，Arch 默认是不装这个的。doas pacman -S mtpfs jmtpfs gvfs-mtp # android 4+ 需要第二个包doas pacman -Sy gvfs-gphoto2 # 照片传输支持清理 archhttps://averagelinuxuser.com/clean-arch-linux/重启文件浏览器thunar -q &amp;amp;&amp;amp; thunarhttps://linuxhint.com/guide_linux_audio/raidfio –name TEST –eta-newline=5s –filename=temp.file –rw=read –size=100m –io_size=2g –blocksize=1024k –ioengine=libaio –fsync=10000 –iodepth=32 –direct=1 –numjobs=1 –runtime=60 –group_reportingfio –name TEST –eta-newline=5s –filename=temp.file –rw=write –size=100m –io_size=2g –blocksize=1024k –ioengine=libaio –fsync=10000 –iodepth=32 –direct=1 –numjobs=1 –runtime=60 –group_reportingfio –name TEST –eta-newline=5s –filename=temp.file –rw=read –size=100m –io_size=2g –blocksize=2k –ioengine=libaio –fsync=10000 –iodepth=32 –direct=1 –numjobs=1 –runtime=60 –group_reportingfio –name TEST –eta-newline=5s –filename=temp.file –rw=write –size=100m –io_size=2g –blocksize=2k –ioengine=libaio –fsync=10000 –iodepth=32 –direct=1 –numjobs=1 –runtime=60 –group_reporting多内核Arch 默认的 Linux 内核叫 linux，这个内核一直是最新的。Arch 还有其他几个内核选择 linux-lts：长期支持，版本旧一点，比 linux bug 少 linux-hardened：强调安全，一些包可能不能用 linux-zen：最新内核，经过微调。更强调低延迟，更耗电，throughput 比 linux 差uname -r # 查看当前内核版本# 安装内核，用哪个装哪个doas pacman -S linux-ltsdoas pacman -S linux-hardeneddoas pacman -S linux-zendoas grub-mkconfig -o /boot/grub/grub.cfg # 重新生成grub配置文件到这就完事了，切换内核需要重启，之后在 grub 界面进 advanced options，选想用的内核就行。此外可以修改 grub 配置让 Arch 记住上次选择的内核，下次开机自动选择。doas vim /etc/default/grub# GRUB_DISABLE_SUBMENU=y # 禁用子菜单，所有内核都直接显示# GRUB_DEFAULT=saved # 默认上次选择的内核# GRUB_SAVEDEFAULT=true # 记录上次选择的内核doas grub-mkconfig -o /boot/grub/grub.cfg # 之后还是要重新生成grub配置文件参考：Different Types of Kernel for Arch Ldockinux and How to Use ThemDockerdoas pacman -S docker # 安装doas systemctl start docker.service # 启动# doas systemctl enable docker.service # 开机自启doas usermod -aG docker $USER # 添加组完全删除rm -rf /var/lib/dockeryay -R dockerFROM ubuntuARG USERNAME=linARG USER_UID=1000ARG USER_GID=$USER_UID# Create the userRUN groupadd --gid $USER_GID $USERNAME \\ &amp;amp;&amp;amp; useradd --uid $USER_UID --gid $USER_GID -m $USERNAME \\ # # [Optional] Add sudo support. Omit if you don&#39;t need to install software after connecting. &amp;amp;&amp;amp; apt-get update \\ &amp;amp;&amp;amp; apt-get install -y sudo \\ &amp;amp;&amp;amp; echo $USERNAME ALL=\\(root\\) NOPASSWD:ALL &amp;gt; /etc/sudoers.d/$USERNAME \\ &amp;amp;&amp;amp; chmod 0440 /etc/sudoers.d/$USERNAME# ********************************************************# * Anything else you want to do like clean up goes here *# ********************************************************# [Optional] Set the default user. Omit if you want to keep the default as root.USER $USERNAMEyay -S nvidia-container-toolkitdocker build . -t cuda查看 cuda 版本nvcc --versiondocker pulldocker image lsdocker rundocker psdocker restartdocker stopdocker commit [CONTAINER ID] [new name]gui dockerzram/etc/systemd/zram-generator.conf[zram0]zram-size = ram / 2[zram1]zram-size = ram / 2[zram2]zram-size = ram / 2[zram3]zram-size = ram / 2Primeyay -S nvidia-primeprime-run steamrclonerclone listremotesrclone rcd –rc-web-gui –rc-pass [password]" }, { "title": "管理和安全", "url": "/posts/management-security/", "categories": "Note, IAP", "tags": "Note, IAP", "date": "2021-12-07 19:35:00 +0800", "snippet": "SNMPSimple Network Management Protocol，3个版本。Agent 161/UDP，Manager 162/UDP网络管理 收集设备状态：SNMP 监控网络流量 解决问题Agent收集信息，存在Management Information Base里，通过SNMP发给Manager，网管在Manager上看。Community：Agent划分成CoomunityMIB是树状结构，private是企业自己定义的，不是不能公开访问的意思安全安全 Confidentiality：只让两端能看到内容 Integrity：防篡改 Avalibility：不被ddos Authenticity：保证信息来源是不是假冒的 Non-repudiation：负责，发了不能说没发过，收到了不能说没收到过 Authentication：两端，你确实是你，对面确实是对面 Authorization：你有权 Accounting：你做了 通信安全 发送者用一把钥匙加密 接收者用另一把解密 公钥由可信第三方分发 访问控制 对外：防火墙 对内： 加密目标：难以暴破方法 乱序 映射加密和解密用 相同的key：对称加密 key需要下发，路上不安全 可以用非对称下发，之后用对称 每组收发需要一把key，N(N-1)/2 加密解密代价小 不同的key：非对称加密 一人两把钥匙，2N 公钥依赖CA分发 私钥加密：是你发的。保证来源，只要公钥能解开来源就是对的，但是信息不保密，大家都可以解 公钥加密：只给你看。保密，只有私钥能解开，但是不保证来源，大家都可以用公钥加密 公私钥加密：先保密，再保证来源 电子签名应用层ssh：secure shellkerberos：传输层网络层" }, { "title": "应用层", "url": "/posts/Application-Layer/", "categories": "Note, IAP", "tags": "Note, IAP", "date": "2021-12-04 19:48:00 +0800", "snippet": " HTML：Hyper Text Markup Language URL：Uniform Resource Locators 协议：http，rtp，rtsp，https… ：// 域名或IP 端口号 文件路径 GET参数 CGI：Common Gateway Interface，可以根据客户端上传数据返回动态网页HTTPHyperText Transfer Protocol 没有状态，所有操作一步完成 服务器端 TCP 80pessive open等待客户端连接 内容是英语不是代码 HTTPS：三层连接（TCP，TLS，HTTP） TLS加密HTTP通信内容，一个TLS连接可以加密多个HTTP连接 过程 客户端向服务器 443/TCP 握手 后续所有内容用TLS加密，放进HTTP HTTP message start-line request line 请求类型 GET：获取文件全文 HEAD：获取文件header基本信息 eg：下一个大文件之前先请一下多大 PUT：创建一个新文件或者覆盖一个已有的，URL是放到哪 POST：和PUT类似，但是URI指定的是谁来处理 PATCH：一串对旧文件的修改 COPY，MOVE，DELETE… URL HTTP版本 status line HTTP版本 状态码 1xx 2xx：成功 200 OK 201 Created：新文件创建 3xx：重定向 301 Moved Permanently：请的东西换地方了 304 Not Modified 4xx：客户端错误 400 Bad Request：request的格式有问题 404 Not Found 5xx：服务器端错误 500 Internal Server Error：服务器内部的问题，比如服务器端代码有bug 505 HTTP Version Not Supported status phrase header 空行 \\r\\n 请求的文件代理：截客户端request，自己作为客户端往服务器request 结合防火墙可以限制客户端访问范围 缓存 更快响应客户端请求 减轻服务器负担 非持久HTTP：HTTP 1.0 每次TCP连接最多传一个文件 接收开始：请求后2RTT 接收结束：2RTT+传文件时间 缺点： 传输前等待时间长 并行传输需要创建很多连接 持久HTTP：HTTP 1.1 建立连接后先不关，顺序传多个文件 Connection: Keep-Alive 接收开始 第一个文件还是2RTT 后续的文件1RTT就可以开始收 缺点： head of line blocking：first come first served，前面有一个大文件，后续的小文件需要等 重发过程会中断新文件传输 HTTP/2：一个连接，数据流而不是文件 数据流可以包含文件内容或头文件 内容优先级 缺点 单个TCP连接，重发仍然中断传输 HTTP/3：使用Quick UDP Internet Connections（QUIC），应用层协议 单管道变多管道 并行传输 处理错误不中断传输 整合传输和安全 使用很多类似TCP的技术 创建连接 丢包的处理 拥塞控制 TCP Fast Open：握手的过程中传数据 第一次握手带上TFO Cookie（如果没有发空的）和要请的数据 服务器的SYN+ACK TFP Cookie有效：直接带数据 TFP Cookie无效：带一个TFO Cookie 第一次创建连接还是2RTT 后续创建连接1RTT就开始收数据 CookieCDNContent Delivery Network，把大文件放的离用户更近，加快传输速度，降低传输成本DNS可以做load balanceDHCPDynamic Host Configuration Protocol，Server UDP/67，Client UDP/68 手动分配：DHCP查表看每个MAC怎么配置 固定分配：记录设备MAC，每次请求给同一组配置 动态分配：出租配置，过期不续就分给其他设备 DHCPDISCOVERY：源IP 0.0.0.0，广播 DHCP Relay拓展可以转发Discovery到广播域外，扩大Server管理范围 Option 82：支持的设备在Discovery里加地理信息，转到Server，Server可以给附近的设备分接近的IP，简化路由[//]: # (TODO:relay细节) DHCPOFFER：收到请求的DHCP服务器都给这个设备分一个IP发过来 可以不进行Discovery，服务器定时给Offer等着host Request DHCPREQUEST：设备广播自己选的IP，Server Identifier标自己选的是哪个服务器的 DHCPACK：被选中服务器回一个确认消息，包含完整具体配置，比如IP租期 DHCPRELEASE：设备自己释放IPIP是租用的，下发的时候带租期，一般租期过半就重新发DHCPREQUEST续租，到期后收回NTPNetwork Time Protocol，通常可以将时间校准到10ms误差以内123 UDP/TCP层次结构 stratum 0：可靠时钟源 stratum 1～15：离时钟源有几层服务器 stratum 1 大概300个 时间戳： Transmit Timestamp：发送host自己时钟的发出时间 Origin Timestamp：client发送请求里的Transmit Timestamp Receive Timestamp：服务器收到请求的时间 Reference Timestamp：NTP服务器最近一次校准时间RTT：Client收发间隔 - Server收发间隔知道单程时间和两组时间戳的差，可以校准主机时钟。通常会请多个NTP服务器，统计方法减小误差NATNetwork Address Translation，将局域网IP映射到公网IP。一般说NAT都是带端口的，PAT和NAPT的意思。步骤 地址绑定 数量 one to one：一个局域网IP给一个公网IP many to one：多个局域网IP给一个公网IP 内网IP+端口映射到公网IP+端口 公网端口只能用动态端口 - 固定 - 静态：映射不顶 - 动态：一段时间内固定，更好的利用端口资源 地址转换 向外 改源IP，源端口 向内 改目标IP，目标端口 地址解绑问题：路由器是三层设备，但是NAT需要改所有4层的IP和端口信息 改了IP和端口号需要重新checksum，额外的计算 一些协议内容里有端口号，也需要改 ICMP报文要带触发数据包IP header和前8 Bytes payload，里面有ip和端口号 FTP PORT命令指定IP和端口号，在内容里 socket TCP UDP RAW：允许程序绕过传输层协议直接用网络曾的IP" }, { "title": "腹部CT", "url": "/posts/Liver-CT/", "categories": "Med, CT", "tags": "Med, CT, Abdominal", "date": "2021-11-28 15:43:00 +0800", "snippet": "CTComputed Tomography进步 5min-&amp;gt;0.5s 5mm-&amp;gt;0.5mm 非螺旋-&amp;gt;螺旋 非螺旋：停，进，每次扫一张 螺旋：床匀速前进，连续旋转，容积扫描 多排 双源多层螺旋CT优点 短：时间短，憋一口气从胸部到盆腔。扫描快，运动伪影少，可以一个心电周期内扫心脏 薄：层厚薄，0.5mm 长：从头到脚，可以对长病变完整成像 优：图像质量好，各向同性 省：X线剂量少发展方向：解剖图像-&amp;gt;功能成像扫描模态 x线：平片 可以看到轮廓，钙化，积液 DSA：Digital subtraction angiography，打显影剂前后的x线进行减影，可以检查和引导手术 超声 CT 平扫：无造影剂。扫描前空腹，喝清水或碘水充盈胃肠 增强：静脉注射显影剂 目的 增加肝组织和正常组织差别 判别病灶性质 鉴别正常血管 MRI 核素 介入：穿刺，DAS窗位 肺窗 纵隔窗：肺内基本是空的 肝解剖人体最大的实质性器官，成人约1～1.5kg，有解毒。。。功能位置：大部分右季肋，腹上区。小部分左季肋。悬吊在膈肌下方形态：右厚左薄，楔形 上面：膈面，圆凸，借助冠状韧带吊在膈肌下方，随呼吸上下运动，幅度2~3cm 横着冠状韧带，竖着镰状韧带 下面：脏面，凹凸不平（其他脏器的压迹），有H形沟 右纵沟 前：胆囊窝，胆囊借助胆囊床附着 后：腔静脉窝，有三条肝静脉汇入下腔静脉（第二肝门）[//]: # (TODO:是汇入吗，血流方向？) 左纵沟 前：肝圆韧带，胚胎期脐静脉闭锁形成 后：静脉韧带，胚胎期静脉导管 横沟（肝门） 肝门三件：每个管道都有左右支进入左右肝 肝总管：肝总管 + 胆囊官 = 胆总管。肝脏下缘，肝总管，胆囊管组成胆囊三角，胆囊动脉从中穿过。 肝固有动脉：营养肝脏 肝门静脉：脾静脉是横断面上的，沿着脾静脉找 神经 淋巴 前缘：锐薄，上面和下面在前方的交界 位置低，也叫肝脏下界 后缘：钝圆 血供 入 肝动脉 肝门静脉：腹部脏器的静脉血从肝门静脉进入肝脏 血流量：70%～75% 供氧量：50% 从胃肠吸收的营养物质 出 肝静脉 肝小叶胆总管 十二指肠上段 十二指肠后段 胰腺段：胰腺后方 十二指肠壁段：穿入十二指肠内肝胰壶腹：胆总管十二指肠内开口和胰管汇合形成，周围有Ossid括约肌，控制胆汁和胰液流出，并防止十二指肠内容物反流投影：在体表判断肝脏大小 上界：从右到左 右锁骨中线：第5肋 正中线：胸骨体和剑突结合部 左锁骨中线：5 6肋间 下界 右肋弓内 剑突下能摸到3cm 判断肝脏大小要综合上下界。上界叩诊 肺：清音 肺肝重合：浊音 肝：实音bismuth分段 纵向中肝静脉分左右，右肝静脉分右前后，镰状韧带分左内外 从右到左：右肝后（右肝静脉）右肝前（中肝静脉）左肝内（镰状韧带）左肝外 纵向门静脉左右支分上下两份中心1，其他顺时针标号解剖标记 第一肝门上方中肝静脉，右肝静脉 门静脉左支分左肝上下 门静脉右支分右肝上下 顺时针在片子里是左到右肝切肝CT 40～60HU，高于胰，脾 肝内管道系统（胆管，肝动脉静脉和门静脉）低于实质，周围小分支多不显示。大血管呈低密度树状影 CTA 动脉期：20～30s 肝门到肝内的树枝样血管影 腹主动脉和肝动脉强化程度差不多 门静脉：50～50s 动脉影消失，门脉显影 门静脉高密度，判断显影剂剂量合不合适 静脉期：100～120S 观察病变 平衡期：120～180s 整个肝密度基本一致，静脉影大部分消失[//]: # (TODO:区分) 正常肝重要结构疾病 肝硬化：肝功不全，门脉高压 变小：肝脏和膈肌之间有间隙 变形： 肝硬化是过度纤维组织增生，纤维组织收缩使肝脏变形 肝脏轮廓凹陷，不平呈波浪状 比例失调 右叶正常应该大于左页 门脉高压：容易形成血栓 门静脉直径超15mm 伴随脾脏增大 脾脏横向超过5个肋单元 纵向看不到肝就应该看不到脾 侧枝循环 胆囊结石：正常胆囊里面液体应该和胃内部类似 肝门内胆囊里有高密度影 胆囊炎： 胆囊壁模糊 肾结石 在集合系统， 空腔附近 囊肿： 壁薄。有张力 -&amp;gt; 边界清晰 内部液体密度：&amp;lt;10HU，类似胃密度 内部密度均匀 CTA不强化 相关视频和网站： https://www.bilibili.com/medialist/play/ml1422834132/BV1gf4y1X77T?spm_id_from=333.999.0.0&amp;amp;oid=286950890&amp;amp;otype=2 https://www.startradiology.com/internships/general-surgery/abdomen/ct-abdomen-general/index.html" }, { "title": "医学影像数据集集锦", "url": "/posts/Medical-Dataset/", "categories": "Med, Dataset", "tags": "Med, Dataset", "date": "2021-11-28 15:43:00 +0800", "snippet": "医学影像数据集集锦前言本项目的目标是整理一个医学影像方向数据集的列表，提供每个数据集的基本信息，并在License允许的前提下提供不限速下载。如果您想使用的数据集不在列表中我们可以提供免费代下。项目按照数据集模态或关注的器官分类。当前共收录约 20 个方向的 80+ 个数据集医学影像数据集众多多且专业性强，众人拾柴火焰高！如果您使用过列表中没有的数据集，或发现列表中的信息有任何疏漏，我们非常希望您可以参与项目建设。联系维护者:me@linhan.email 微信 linhandev目录================= 医学影像数据集集锦 前言 目录 肝脏 LiTS Sliver07 3D-IRCADB CHAOS TCGA-LIHC MSD肝脏血管分割 肺 MSD肺癌分割 LoLa11肺叶分割 StructSeg2019 肺部多病智能诊断 CheXpert NIHChest Xray QIN Lung CT 4D-Lung NSCLC-Radiomics vessel12 肺部血管分割 肺结核 Shenzhen Hospital X-ray Set Montgomery County X-ray Set 肺炎 Ieee8023 covid19-ct-scans COVID-CT Figure1-COVID-chestxray-dataset RSNA肺炎检测 CovidX Flyai Covid covid19-radiography-database COVID-19-AR CT Images in COVID-19 肺结节 LIDC-IDRI LUNA16 天池肺部结节 LNDB Lung Nodule Malignancy Data Science Bowl 17 Lung-PET-CT-Dx 气胸 SIIM-ACR Pneumothorax Segmentation 胸 CBIS-DDSM QIN Breast Rider Breast MRI ACRIN 6688 BraTS2013 BraTS2015 BraTS2021 脑 MSD脑瘤分割 MSD海马体分割 Iseg2019 ABIDE ADNI CQ500 脑出血 RSNA Intracranial Hemorrhage Detection 肾脏 Kits19 肠 CT COLONOGRAPHY MSD肠道分割数据集 心脏 EchoNet MMWHS MSD心脏分割 主动脉 冠状动脉分割 眼睛 DRIVE ODIR-5k FIRE 视网膜图像数据 STARE CHASE_DB1 IDRiD 前列腺 PANDA MSD前列腺分割 QIN-PROSTATE-Repeatability 胰腺 MSD胰腺分割 PDMR-833975-119-R 皮肤 SIIM-ISIC Melanoma Classification 细胞 Data Science Bowl 18 血细胞涂片分类 ISBI细胞跟踪 骨骼 MURA-1.1 RSNA Bone Age 磁共振图像脊柱结构多类别三维自动分割 膝盖 MRNet 脊椎 Verse大规模脊椎分割数据集 VQA PathVQA 内窥镜 SARAS-MESAD SARAS-MESAD 数字病理 CAMELYON 心电图 CAMELYON 交流群 医学影像数据库 参考项目/列表 贡献者 Release Note 肝脏 LiTS 名称 标注内容 类型 模态 数量 标签格式 文件格式 License LiTS 肝脏/肝脏肿瘤 分割 CT 131+70 0/1标签 nii CC BY-NC-ND 4.0 LiTS数据集包含131套训练扫描和70组测试数据，其中70组测试数据标签不公开。LiTS训练集中包含3DIRCADB中的所有数据，所以如果合并多个数据集不要合并这两个。Medical Segmentation Decathlon中肝脏分割的数据集就是LiTS。分割结果可以在线提交进行评估，在线提交方法参考。 在线提交地址数据集论文：The Liver Tumor Segmentation Benchmark (LiTS)相关项目： 基于Paddle的肝脏CT影像分割Aistudio下载Sliver07 名称 标注内容 类型 模态 数量 标签格式 文件格式 License Sliver07 肝脏 分割 CT 20+10 0/1标签 MetaImage Other 这个数据集比较老了，现在用的也比较少，一些研究会将sliver和lits合起来，这样基本上就是所有常用的关于肝脏分割的公开数据了。mhd格式可以用 SimpleITK 读，在medseg项目中有转换成nii的脚本Aistudio下载3D-IRCADB 名称 标注内容 类型 模态 数量 标签格式 文件格式 License 3D-IRCADb 01 02 肝脏/肝肿瘤 分割 CT 20+2 surface mesh dcm CC 3D-IRCADb是比较早的一个数据集，有两个子集，分别包含20组和2组CT片子。Aistudio下载CHAOS 名称 标注内容 类型 模态 数量 标签格式 文件格式 License CHAOS 肝/肾/脾 分割 CT+MRI 40CT+120MRI 0/1标签 dcm CC 4.0 CHAOS是一个多脏器，多模态分割数据集。Aistudio下载TCGA-LIHC 名称 标注内容 类型 模态 数量 标签格式 文件格式 License TCGA-LIHC 肝   CT/MR/PT 97患者/237套 无标签 dcm Other Aistudio下载MSD肝脏血管分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD肝脏血管分割 肝脏血管 分割 CT 443 0/1 nii CC-BY-SA 4.0 Aistudio下载肺MSD肺癌分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD肺癌分割 肺脏 分割 CT 96 0/1 nii CC-BY-SA 4.0 Aistudio下载LoLa11肺叶分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License LoLa11 None 分割 CT 55 None Metaimage Other LoLa11 包含55套CT数据，未发现任何公开标注信息zenodo下载StructSeg2019 名称 标注内容 类型 模态 数量 标签格式 文件格式 StructSeg2019             肺部多病智能诊断 名称 标注内容 类型 模态 数量 标签格式 文件格式 肺部多病智能诊断     CT       CheXpert 名称 标注内容 类型 模态 数量 标签格式 文件格式 License CheXpert             Other 介绍论文： CheXpert: A Large Chest Radiograph Dataset with Uncertainty Labels and Expert Comparison相关项目NIHChest Xray 名称 标注内容 类型 模态 数量 标签格式 文件格式 License NIHChest Xray 14种肺部疾病/部分病灶位置 分类/检测 CXR 112,120 csv png CC0: Public Domain 介绍论文： ChestX-ray8: Hospital-scale Chest X-ray Database and Benchmarks on Weakly-Supervised Classification and Localization of Common Thorax DiseasesAistudio下载QIN Lung CT 名称 标注内容 类型 模态 数量 标签格式 文件格式 License QIN Lung CT 非小細胞癌   CT 47   dcm Other Aistudio下载4D-Lung 名称 标注内容 类型 模态 数量 标签格式 文件格式 License 4D-Lung 非小細胞癌   CT   20 dcm Other Aistudio下载NSCLC-Radiomics 名称 标注内容 类型 模态 数量 标签格式 文件格式 NSCLC-Radiomics 非小细胞癌　 分割　 　CT 422   dcm Aistudio下载vessel12 肺部血管分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License vessel12 肺部血管分割 肺部血管 分割　 　CT 20   raw   Aistudio下载肺结核Shenzhen Hospital X-ray Set 名称 标注内容 类型 模态 数量 标签格式 文件格式 Shenzhen Hospital X-ray Set 肺结核/正常 分类 CXR 662 类别 图片 深圳第三医院收集的肺结核胸透数据集，包含326张正常扫描和336张不正常的扫描。Aistudio下载Montgomery County X-ray Set 名称 标注内容 类型 模态 数量 标签格式 文件格式 Montgomery County X-ray Set 肺结核/正常 分类 CXR 138 类别 图片 蒙哥马利市收集的肺结核胸透数据集，包含80张正常的扫描和58张不正常的扫描。Aistudio下载肺炎Ieee8023 名称 标注内容 类型 模态 数量 标签格式 文件格式 Ieee8023 肺脏 分类 CT 20   nii 持续搜集公开的新冠CT扫描，目前有20个病例。Aistudio下载covid19-ct-scans 名称 标注内容 类型 模态 数量 标签格式 文件格式 covid19-ct-scans 左右肺/新冠感染 分割 CT 20   nii 数据来自Ieee8023，对20组扫描进行了左右肺和感染区的标注。基于这个数据集和另外几个数据集，大佬们做了一个新冠分割的 benchmarkAistudio下载COVID-CT 名称 标注内容 类型 模态 数量 标签格式 文件格式 COVID-CT   分类 CT 349   图片 包含216名新冠患者的349张胸部CT图片，从相关paper中收集。Aistudio下载Figure1-COVID-chestxray-dataset 名称 标注内容 类型 模态 数量 标签格式 文件格式 Figure1-COVID-chestxray-dataset   分类 CXR 48   图片 DarwinAI收集的一些新冠CT的图片，是CovidX数据集的一部分。持续更新，使用前可以先pull。Aistudio下载RSNA肺炎检测 名称 标注内容 类型 模态 数量 标签格式 文件格式 RSNA肺炎检测 之否肺炎/肺炎区域BB 分类/检测 CXR 26684+3000   图片 RSNA是北美放射学会在Kaggle上组织的一个比赛数据集，数据来自NIH。包含26684张训练数据，有图片的分类和肺炎区域的边界框。Aistudio下载CovidX 名称 标注内容 类型 模态 数量 标签格式 文件格式 CovidX 新冠/其他肺炎/正常 分类 CT 13569+231   图片 CovidX数据集是DarwinAI训练CovidNet做的一个数据集，本身没有新的数据，是Ieee8023，Figure1和RSNA组合成的一个数据集。Flyai Covid 名称 标注内容 类型 模态 数量 标签格式 文件格式 Flyai Covid             Flyai举办的一个新冠分类比赛。Aistudio下载covid19-radiography-database 名称 标注内容 类型 模态 数量 标签格式 文件格式 covid19-radiography-database 新冠/其他肺炎/正常 分类 CT 219+1314+1345   图片 跟CovidX一样是一个组合数据集，数据来自论文图片和RSNA。Aistudio下载COVID-19-AR 名称 标注内容 类型 模态 数量 标签格式 文件格式 COVID-19-AR           dcm Chest Imaging with Clinical and Genomic Correlates Representing a Rural COVID-19 Positive Population (COVID-19-AR)Aistudio下载CT Images in COVID-19 名称 标注内容 类型 模态 数量 标签格式 文件格式 CT Images in COVID-19 无标签 分类/分割 CT 650 无 nii Aistudio下载肺结节LIDC-IDRI 名称 标注内容 类型 模态 数量 标签格式 文件格式 LIDC-IDRI 肺部肿瘤 目标检测 CT 1012 xls dcm 介绍论文： The Lung Image Database Consortium (LIDC) and Image Database Resource Initiative (IDRI): A Completed Reference Database of Lung Nodules on CT ScansThe public cancer radiology imaging collections of The Cancer Imaging ArchiveAistudio下载 Part1 Part2LUNA16 名称 标注内容 类型 模态 数量 标签格式 文件格式 LUNA16             Aistudio下载天池肺部结节 名称 标注内容 类型 模态 数量 标签格式 文件格式 License 天池肺部结节 肺部结节 检测 低剂量肺部CT 1000(初赛) + 2000(复赛) 位置+直径 mhd Custom LNDB 名称 标注内容 类型 模态 数量 标签格式 文件格式 LNDB 直径大于3mm的肿瘤分割标注/小于3mm肿瘤和非肿瘤标记中心 分割/分类 CT 294 XML MetaImage 介绍论文： LNDb: A Lung Nodule Database on Computed TomographyAistudio下载Lung Nodule Malignancy 名称 标注内容 类型 模态 数量 标签格式 文件格式 Lung Nodule Malignancy 肺结界良恶性 分类 CT 4165+2526   tif Aistudio下载Data Science Bowl 17 名称 标注内容 类型 模态 数量 标签格式 文件格式 Data Science Bowl 17             Aistudio下载Lung-PET-CT-Dx 名称 标注内容 类型 模态 数量 标签格式 文件格式 Lung-PET-CT-Dx 肺癌　 目标检测 CT 363 xml dcm 气胸SIIM-ACR Pneumothorax Segmentation 名称 标注内容 类型 模态 数量 标签格式 文件格式 SIIM-ACR Pneumothorax Segmentation             胸CBIS-DDSM 名称 标注内容 类型 模态 数量 标签格式 文件格式 CBIS-DDSM 正常/良性/恶性 分类 CT 2620     介绍论文： Deep Learning to Improve Breast Cancer Early Detection on Screening Mammography A curated mammography data set for use in computer-aided detection and diagnosis researchAistudio下载QIN Breast 名称 标注内容 类型 模态 数量 标签格式 文件格式 QIN Breast 0102     MRI 67     Aistudio下载Rider Breast MRI 名称 标注内容 类型 模态 数量 标签格式 文件格式 Rider Breast MRI     MRI       ACRIN 6688 名称 标注内容 类型 模态 数量 标签格式 文件格式 ACRIN 6688     CT 83     Aistudio下载BraTS2013 名称 标注内容 类型 模态 数量 标签格式 文件格式 BraTS2013             BraTS2015 名称 标注内容 类型 模态 数量 标签格式 文件格式 BraTS2015             Aistudio下载BraTS2021 名称 标注内容 类型 模态 数量 标签格式 文件格式 BraTS2015             脑MSD脑瘤分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD Brain Tumor Segmentation 胶质瘤/肿瘤/水肿 分割 MRI 484 Train + 266 Test 0/1 nii CC-BY-SA 4.0 Aistudio下载MSD海马体分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD Hippocampus Segmentation 海马体 分割 MRI 394 0/1 nii CC-BY-SA 4.0 Aistudio下载Iseg2019 名称 标注内容 类型 模态 数量 标签格式 文件格式 Iseg2019             ABIDE 名称 标注内容 类型 模态 数量 标签格式 文件格式 ABIDE 是否有自闭症 分类 MRI 539+573     自闭症患者的头部MRI扫描，包含539例自闭症患者和573个正常扫描对照组。 介绍论文： The autism brain imaging data exchange: towards a large-scale evaluation of the intrinsic brain architecture in autism.下载地址ADNI 名称 标注内容 类型 模态 数量 标签格式 文件格式 ADNI             介绍论文： Alzheimer’s Disease Neuroimaging Initiative (ADNI)CQ500 名称 标注内容 类型 模态 数量 标签格式 文件格式 License CQ500   分割   CT 491组扫描   by-nc-sa 4.0 介绍论文:Development and Validation of Deep Learning Algorithms for Detection of Critical Findings in Head CT Scans脑出血RSNA Intracranial Hemorrhage Detection 名称 标注内容 类型 模态 数量 标签格式 文件格式 RSNA Intracranial Hemorrhage Detection     CT       Aistudio下载肾脏Kits19 名称 标注内容 类型 模态 数量 标签格式 文件格式 License Kits19 肾脏/肾肿瘤 分割           Aistudio下载肠CT COLONOGRAPHY 名称 标注内容 类型 模态 数量 标签格式 文件格式 CT COLONOGRAPHY     CT       包含没有结肠息肉，有6-9mm息肉和大于10mm息肉的数据。MSD肠道分割数据集 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD肠道分割数据集 结肠癌原发病灶 分割 CT 126训练+64测试     CC-BY-SA 4.0 Aistudio下载心脏EchoNet 名称 标注内容 类型 模态 数量 标签格式 文件格式 EchoNet 心脏 分割 MRI 10300 0/1   介绍论文： EchoNet-Dynamic: a Large New Cardiac Motion Video Data Resource for Medical Machine LearningMMWHS 名称 标注内容 类型 模态 数量 标签格式 文件格式 MMWHS 心脏 分割 CT / MRI 20CT、20MRI 类别 nii mmwhs是心脏分割数据集，共有8类，MRI和CT两种模态 相关项目： Hybrid Loss Guided Convolutional Networks for Whole Heart ParsingAistudio下载MSD心脏分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD心脏分割 左心房 分割 MRI 20(训练)+10(测试)     CC-BY-SA 4.0 Aistudio下载主动脉冠状动脉分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License Automated Segmentation of Coronary Arteries 冠状动脉 分割 CTA 40+20     Custom Grand Challenge下载眼睛DRIVE 名称 标注内容 类型 模态 数量 标签格式 文件格式 DRIVE 眼底血管 分割 眼底照片 40 0/1 图片 DRIVE数据集是一个糖尿病病人眼底血管分割数据集。Aistudio下载ODIR-5k 名称 标注内容 类型 模态 数量 标签格式 文件格式 ODIR-5k 正常和7种疾病 分类 眼底彩色照片 5000   图片 ODIR-5K包括5000名患者的年龄，双眼的彩色眼底照片和医生的诊断关键词。该数据集是上工医疗技术有限公司从中国不同医院/医疗中心收集的“真实”患者信息。在这些机构中，眼底图像由市场上的各种相机捕获，例如Canon，Zeiss和Kowa，因此导致各种各样的图像分辨率。病人的识别信息会被移除。注释由经过培训的人类读者进行标记，并具有质量控制管理。患者分为8个标签，包括正常（N），糖尿病（D），青光眼（G），白内障（C），AMD（A），高血压（H），近视（M）和其他疾病/异常（O）。FIRE 视网膜图像数据 名称 标注内容 类型 模态 数量 标签格式 文件格式 FIRE 视网膜图像数据   分类 视网膜图像 129     FIRE 是一个视网膜眼底图像数据集，包含 129张 眼底视网膜图像，由不同特征组合成 134对 图像组合。这些图像组合根据特质被划分为3类。眼底图像由 Nidek AFC-210 眼底照相机采集，分辨率为2912x2912，视觉仰角为40度。图像由 Papageorgiou Hospital 医院和Aristotle University of Thessaloniki大学共同构建，由于Thessaloniki 大学采集自39名患者。. 数据包括以下几部分内容： 1.成对的视网膜图像。 2.彩色ROI掩模（作为二值图像）。 3.特征ROI掩模（作为二值图像）。 4.每个图像对应的标注点。STARE 名称 标注内容 类型 模态 数量 标签格式 文件格式 License STARE 眼底血管 分割 眼底照片 400 照片 照片 无 STructured Analysis of the Retina数据集包含400张眼底照片，作者团队对这些数据进行了多种诊断，并对部分数据的血管进行了标注Aistudio下载CHASE_DB1 名称 标注内容 类型 模态 数量 标签格式 文件格式 License CHASE_DB1 眼底血管 分割 眼底照片 28 png png 无 Kinston大学公开的一个小规模眼底分割数据集，包含28张眼底照片及对应的分割标签。Aistudio下载IDRiD 名称 标注内容 类型 模态 数量 标签格式 文件格式 License IDRiD 常见DR病灶、视盘、DR病变等级等 分类、检测、分割 眼底照片 * tif/csv jpg CC BY 4.0 Indian Diabetic Retinopathy Image Dataset (IDRiD)Aistudio下载前列腺PANDA 名称 标注内容 类型 模态 数量 标签格式 文件格式 PANDA 前列腺癌分级   镜检图片 10616张镜检 分类 tiff MSD前列腺分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD前列腺分割 前列腺中央腺体及外周区域 分割 多模态核磁 32(训练)+16(测试)     CC-BY-SA 4.0 Aistudio下载QIN-PROSTATE-Repeatability 名称 标注内容 类型 模态 数量 标签格式 文件格式 QIN-PROSTATE-Repeatability 前列腺癌　   MRI 15 　　 dcm Aistudio下载胰腺MSD胰腺分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License MSD胰腺分割 胰腺肿瘤 分割 CT 282(训练)+139(验证) 0/1 nii CC-BY-SA 4.0 Aistudio下载PDMR-833975-119-R 名称 标注内容 类型 模态 数量 标签格式 文件格式 PDMR-833975-119-R 　胰腺癌　   　MRI 20   dcm Aistudio下载皮肤SIIM-ISIC Melanoma Classification 名称 标注内容 类型 模态 数量 标签格式 文件格式 SIIM-ISIC Melanoma Classification 皮肤癌病变类别 分类 皮肤镜 88.3K张图片 类别 dicom 目前最大的皮肤镜图像集合，用来在皮肤病变图像中之别黑色素瘤，图片以DICOM格式提供，同时包含图像元数据，有的图像也以JPEG和TFRecord格式提供，TFRecords格式的图像已被调整为统一的1024x1024细胞Data Science Bowl 18 名称 标注内容 类型 模态 数量 标签格式 文件格式 Data Science Bowl 18 细胞核 分割   841张/37333个细胞核 0/1 图片 细胞核分割数据集介绍论文： Nucleus segmentation across imaging experiments: the 2018 Data Science BowlAistudio下载血细胞涂片分类 名称 标注内容 类型 模态 数量 标签格式 文件格式 血细胞涂片分类 四种血细胞类型 分类 镜检 12500 - 图片 血细胞分类数据集包含12500张四种血细胞的照片。图片是从大的血细胞涂片照片上截下来的，数据集经过增广。图片都很小，训练时注意IO瓶颈。Aistudio下载ISBI细胞跟踪 名称 标注内容 类型 模态 数量 标签格式 文件格式 ISBI细胞跟踪 细胞像素级别位置 跟踪 镜检     图片 在镜检视频中像素级跟踪细胞位置Aistudio下载 2D+Time Datasets骨骼MURA-1.1 名称 标注内容 类型 模态 数量 标签格式 文件格式 MURA-1.1 正常/非正常 分类 x-ray 40561     介绍论文： MURA: Large Dataset for Abnormality Detection in Musculoskeletal RadiographsAistudio下载RSNA Bone Age 名称 标注内容 类型 模态 数量 标签格式 文件格式 RSNA Bone Age             Aistudio下载磁共振图像脊柱结构多类别三维自动分割 名称 标注内容 类型 模态 数量 标签格式 文件格式 License 磁共振图像脊柱结构多类别三维自动分割 椎骨和椎间盘 分割 MRI T2WI 172 0/1 nii Custom Aistudio下载膝盖MRNet 名称 标注内容 类型 模态 数量 标签格式 文件格式 MRNet             Aistudio下载脊椎Verse大规模脊椎分割数据集 名称 标注内容 类型 模态 数量 标签格式 文件格式 License VerSe 脊椎 分割         CC BY-SA 4.0 Aistudio下载VQAPathVQA 名称 标注内容 类型 模态 数量 标签格式 文件格式 PathVQA     图片 4998图片/32799问答   图片 介绍论文： PathVQA: 30000+ Questions for Medical Visual Question AnsweringAistudio下载内窥镜SARAS-MESAD 名称 标注内容 类型 模态 数量 标签格式 文件格式 License SARAS-MESAD 24种动作 静态背景动作识别 内窥镜 4(真实手术)+5(模拟手术)     CC BY-NC-SA 4.0 SARAS-MESAD 名称 标注内容 类型 模态 数量 标签格式 文件格式 License SARAS-ESAD 21种手术动作 静态背景动作识别 内窥镜 22,601(训练)+4,574(测试) 图片 BB CC BY-NC-SA 数字病理CAMELYON| 名称 | 标注内容 | 类型 | 模态 | 数量 | 标签格式 | 文件格式 | License || - | - | - | - | - | - | - | - || CAMELYON16，17 | | | 镜检 | | 图片 | BB | CC0 |心电图CAMELYON| 名称 | 标注内容 | 类型 | 模态 | 数量 | 标签格式 | 文件格式 | License || - | - | - | - | - | - | - | - || TUH EEG信号 | 癫痫类别 | 分类 | 心电图 | 发作数 2377 | 癫痫发作类别 | edf | can be used for both research and commercialization purposes |交流群如果您对医学影像技术感兴趣，欢迎加入医学影像技术交流群 365213556 ，与更多大佬一起交流，共同进步！医学影像数据库TCIA:The Cancer Imaging ArchiveMedPix 包含超过12000名患者和59000张影像Belarus tuberculosis portal 包含结核病人的CT，胸透和检验数据Grand ChallengesLONI 神经相关医学影像TUH EEG Temple大学脑电波公开数据库，包含超过4T数据参考项目/列表医学影像分割挑战胸部\\肺部ct数据集adalcabeamandrewStanford ML Groupomic tools各领域公开数据集medical-imaging-datasetsOpen-Access Medical Image RepositoriesMedical Image Datasets Download LinksHAM10000 datasetDermatology Image Classificationhavarduscburkelyisdisradiopediaaimi贡献者（按照首次贡献时间排序）多语言代码生成器 Mail : linhandev@qq.com自尊心3底迪ChenchenHu007lixinhui541吖吖查parap1uie-sJianpeng ZhaoAmandalalaRelease Note2021/5/21开始添加数据集图片，接受多次外部贡献，对存量数据集进行合规检查，数据集总量达到712020/11/20添加Issue模板，鼓励外部贡献，数据集数量达到672020/11/8在Github发布，整理格式，添加多个数据集2020/6/11添加LIDC-IDIR，编写数据压缩脚本2020/6/4添加MMWHS心脏分割数据集，SIIM皮肤病分类比赛数据集2020/5/27添加ISBI细胞分割，TCGA-LIHC肝脏，4D-Lung肺部数据集，围绕乳腺癌添加一系列数据集2020/5/20项目添加数据集计数和release note，数据集方面添加 RSNA骨龄，PathVQA，FIRE视网膜，DDSM乳腺癌等数据集2020/5/13项目在Aistudio公开，包含约40个数据集" }, { "title": "网络层", "url": "/posts/Network-Layer/", "categories": "Note, IAP", "tags": "Note, IAP", "date": "2021-11-28 00:07:00 +0800", "snippet": "IPv4 32位，v6 128位loopback interface：帧沿着协议栈下去再上来，不会出现在interface硬件上 ip 一般是127.0.0.1，localhost 127.0.0.1～127.0.0.254，都是localhost 127.255.255.255是一个广播地址，但是lo不支持BROADCAST 作用 在本机上测试C/S架构的程序 localhost ping通说明TCP/IP协议栈没问题 Classful IP Class A：1位，1个7 Class B：2位，2个7 Class C：3位，3个7 Class D：4位，组播 Class E：5位，预留公网不能用的IP主要有：完整列表 loopback：127/8 127.0.0.0～127.255.255.255 link-local：DHCP宕了大家可以ARP探已经占用的IP，给自己一个link-local IP 169.254/16 169.254.0.0～169.254.255.255 0/8：没有IP的设备用于表明自己 局域网IP：局域网设备可以复用IP;局域网数据不会上公网，更安全 10/8：10.0.0.0～10.255.255.255 172.16/12：172.16.0.0～172.31.255.255 192.168/16：192.168.0.0～192.168.255.255 组播IP：224.0.0.0～239.255.255.255 实验IP：240.0.0.0～225.225.225.225CIDRClassless Interdomain Routing，用子网掩码区分network id和host id，让网段的长短和host的数量更贴近。可以多次分段 节省IP：分给一个组织的网段长度更接近实际需要的数量 简化路由：一些子网在远处的路由上可以合并，减少路由记录数量划分网段 host部分全0：网段IP host部分全1：广播IP 第一个IP通常给gateway给出 一段待划分的ip 一些子网，每个要能放下一定数量的host一般按host数量从大到小分 确定host数量的要求需要几位host ID来满足 host ID全0是网段地址，全1是广播地址，一般第一个IP给网关 n个host需要n + 3个地址，找大于等于n+3最小的 2^x 7个host 3位host id是不够的，3位最多8 - 2 = 6个host，还得有一个网关 确定host id h位，network id就是32-h位 计算掩码部分不变，host id全1的广播地址，是这个网段广播ip 下一个网段的ip是上一个网段广播ip+1 e.g：10.189.24.0/24分三个网段，一个100 host，两个10 host 100 host 从 10.189.24.0 开始 100 host至少103个地址，host id 7位 网段地址 10.189.24.0 掩码 25 位 10.189.24.0/25 广播地址掩码部分不变，host id全是1 10.189.24.127 10 host 从 10.189.24.128 开始 10 host至少需要13个地址，host id 4位 网段地址 10.189.24.128 掩码 28 位 10.189.24.128/4 广播地址 10.189.24.143 10 host 从10.189.24.144 开始 10 host至少需要13个地址，host id 4位 网段地址 10.189.24.144 掩码 28 位 广播地址 10.189.24.159 网段地址肯定是偶数，广播地址肯定是奇数路由确定下一跳，转发数据包收到数据包 检查IP和子网掩吗 和自己一个网段 直接送达 不和自己一个网段 间接送达：查路由表，给下一跳 最长前缀匹配：目标Host IP &amp;gt; 目标网段 &amp;gt; 默认网关 没有match：报告错误，丢掉数据包 Routing Table信息来源 手动设置 ICMP更新 动态路由协议配置内容 目标IP：具体IP或网段 下一跳IP Flag U：下一跳在线 G：Gateway 下一跳是路由器 H：Host 下一跳是host D：这条信息是ICMP重定向创建的 M：这条信息是ICMP重定向修改的 走哪个interface发路由表需要经常查，越短越好ICMP Type：大类。8 Echo Request，0 Echo Reply，11 Time Exceeded，3 Destination Unrechable。完整列表 Code：大类下的小类。比如Destination Unreachable有15种具体情况，3是端口不可达，比如端口没开;4是需要分块但是DF set了。 Checksum：checksum先置0，用整个帧算checksum写在这 Rest of Header：不同的类别有不同的格式 Data：最多576 Bytes。包含产生错误packet的IP V4 header和至少前8 Bytes数据（假定传输层协议的端口号应该在前8 Bytes里）重定向没必要发给我，直接给下一跳 路由器收到一个数据包，发现路由表里下一跳就在收数据包的端口上 转发数据 回ICMP redirect错误 host更新路由表，后续流量不再绕一下 redirect有timeout host不一定听redirect 路由发现ICMP route discovery solicitation：启动过程中host给 224.0.0.2 所有路由器的组播发ICMP router solicitation请网关信息 advertisement：host收到路由信息选一个默认网关 路由器回ICMP router advertisement 固定时间间隔就发 静态路由用于 网络规模小 没有冗余路径 和外界单点连接路由信息来源 DHCP 本地配置文件 ICMP 重定向 ICMP 路由发现动态路由 IGP：interior gateway protocols，AS内用，不管AS外的网络 eg Routing Information Protocol (RIP) Open Shortest Path First protocol (OSPF) EGP：exterior gateway protocols，AS间用 每个AS至少有一个路由器负责AS见的路由 eg Border Gateway Protocol(BGP) 代价： path length reliability delay bandwidth traffic 可能导致路由震荡：大家都走现在流量最小的路径，更新之后这个路径就成流量最多的了 communication cost路由算法 distance vector routing：距离口耳相传 只发自己到不同目标的最小代价，不转发别人的信息 split horizon：不告诉你我去哪经过你最近 只知道去哪下一跳该走哪 优点 简单 节省计算和带宽 缺点 收敛慢 Count to Infinity -&amp;gt; 互相count形成环路 link state routing：网络拓扑口耳相传 发自己的连接状态，并且转发别人的信息 每个节点都知道整个网络拓扑 优点 收敛快 缺点 占用资源多 计算：每个路由器重复计算路由表 带宽：每个路由器的连接状态需要过每一根网线 RIPRouting Information Protocol RIP，RIP-2，RIP-ng（IP v6） 520/UDP 代价只能是跳数，最多15跳，16跳代表unrechable 只存最优路径 触发路由信息发送 定时发送 路由表更新 和邻居的代价发生变化 / 有新路由器入网 收到邻居的路由信息，计算后发现更短路径 定时器 route-update：默认30s + 小的随机时间，大家错开 倒计时结束就发自己的路由信息 route-invalid：默认180s 过了这么长时间没收到下一跳消息 标记这个路径inaccessible 广播经过自己到目标的这个路径unreachable 会往下传播告诉所有到达这个目标经过这个路径的路由器这个路径不可达了，但是不影响到达这个目标不走这个路径的路由器 但是还会向这个下一跳转数据包：源在听到不可达之前还在发数据，能不能到都试着把这些送过去 route-hold-down：默认180s，至少route-update三倍 听到一个路径unrechable后，route-hold-down时间内不更新这个路径 route-flush：默认240s，需要比route-invalid和route-hold-down都大 经过route-flush删除这条路径信息 Count to Infinity Router B原来通过Router A到LAN A Router A到LAN A的连接宕掉了 Router A听Router B的路由信息发现Router B有一条到LAN A 1跳的路径 Router A标记去LAN A下一跳Router B，距离2跳 Router B发现下一跳Router A去LAN A的最短路径更新了 Router B标记去LAN A下一跳Router A，距离3跳 …… Count to Infinity避免Count to Infinity RIP里数到16路径unrechable 缺点 限制网络规模 数到16还是要时间 route-hold-down 路径宕掉了通知所有最短路径包含这条路径的路由器 计时期间路径不更新，两个人不许互相数 其他的路径在倒计时期间被添加 horizontal split 不告诉你我去哪经过你最近 black hole：一个路由器可以说我到所有路由器的距离都很近，这样网络上很多路由都会经过自己ospfOpen Shortest Path First，IP组播，协议号89 支持多种代价 支持多路径 不同服务走不同路径保证质量 负载均衡 收敛快 分级路由 级别 AS Area：每个Area一个32 bit ID 骨干Area：只有一个，ID 0.0.0.0 路由器 AS边界 区域边界：不完全包含在任何区域里 OSPF骨干：所有区域边界和把区域边界连起来的路由器 内部路由器 消息 Hello：发现邻居，监测邻居状态 Database description LinkState Request Update Acknowledgement adjacent：link state dataset相同迪杰斯特拉 已知最短路径的点是一个集合 每次找出和集合相邻的点中离源点最近的点，加入已知集合 循环进行：O(n^2) 优先队列：O(nlog(n)) BGPBorder Gateway Protocol，AS间路由协议。TCP/179 跟RIP一样是距离矩阵算法 记录完整路径 记录所有的路径，不是只要最好的路径 两部分 External BGP：学习到其他AS的路径 交换信息 目标网络 经过的AS 政策 告诉其他路由器什么 如何选择路径 Internal BGP：将外部信息告诉自己AS里的路由器 流量类型 内部流量 从AS内产生的 目的地在AS内的 通勤流量：只是从AS过。在AS外产生，目的地也在AS外 AS类型 Stub AS：只连一个AS，死胡同 Multihomed AS：连两个或以上AS，但是不接通勤流量 Transit AS：接两个或以上AS，而且允许通勤流量 MPLSMulti-protocol label switching在二层和三层报头之间指定forward方法，可以在packet switch网络上给数据流固定路径 避免动态路由协议开销 traffic engineering更高效利用带宽 绕开拥堵 区分对待不同服务，保证一些服务质量 比如VoIP和best effort分开，给VoIP质量更好的线路 可以只经过信任路由器，更安全Traceroute没进行一次路由决策，IP包的TTL就-1。在到达host的时候TTL不减发UDP数据包，TTL从1开始，每次 +1 途中的router回ICMP Time Exceeded，TTL expired in transit 目标设备回Destination Unreachable，Destination port unreachable每个发出去的包目标端口号不同，看ICMP的payload可以知道是哪个包触发的，从而计算RTTUDP将第三层的IP延伸到第四层，加入多播，端口号和一个checksum特点 无连接，不可靠 不保证送达 不保证顺序 简单 快 不可靠的协议上也可以做可靠的服务，应用层需要加入保证可靠的功能TFTPTrivial File Transfer Protocol，服务器 69/udp 接控制，之后开一个动态端口传数据;客户端两个动态端口，一个控制一个数据。一块数据一个ack 客户端给服务器69/UDP发一个文件请求 服务器端发一个block数据 客户端一个ack 服务器端发下一个block 如果超时没有等到ack重发 反复直到发完 没有监权 没有加密TCPTransmission Control Protocol，只支持单播，对上层暴露byte stream。ack的byte是已经成功接收的byte + 1，就是下一次期望接收的byte帧格式 Source/Destination port number：发送和接收的端口号 Sequence Number：这个报文第一个Byte在发送的数据流中是第多少Byte，纯ACK报文不占ID，也不需要被ACK Acknowledgement Number：接收端期待收到第几个Byte，收到了x就ACK x+1 Data Offset/Header Length：TCP报头的长度，单位word（4 Bytes） Flags：1 set ACK：说明ACK值是有用的 SYN：建立连接 FIN：中断连接 RST：出问题了终止连接，或者收到SYN的时候直接回RST拒绝连接 PSH：发送端告诉接收端应该尽快把数据交给上层，可能传输要结束了 Window Size：rwnd，接受端在发送这个报文的时候最多还能收多少Byte Checksum：计算用到IP伪报头，TCP报头和payload Urgent Pointer：如果URG=1，指向Payload里紧急消息 面向连接，可靠 错误控制：每个数据包要ack，丢失或出错重发 出错：任何一层checksum没过 继续ack上一次的byte 丢失：Retransmission Timer timeout重发 RTO（Retransmisson Timeout）应该比RTT大，但是在一个数量级 RTO不足1s进位，最大可能有cap，一般60s 重发帧的RTT不参与运算，重发帧也timeout了RTO*2 SACK：selective ack，不是所有host都支持 还是ACK出错的byte 同时SACK这个出错的包后面成功收到了什么 避免一个包出错就卡住传输 流控制：滑动传口避免接收缓冲区溢出 拥塞控制：slow start，congestion avoidance，fast retransmission 全双工：双向可以同时通信建立连接 确认 maximum segment size：最大一个包多大，一般实际就发这么大 receiving buffer size：接受端buffer大小 initial sequence number：随即的 三次握手 SYN SYN+ACK ACK 拒绝连接用RST断开连接 两端都可以断开连接 TCP Half Close：一端还没发完另一端就可以先断 最后一个ACK之后要等两个maximum segment life，防止这个连接没到的数据包影响下一个连接 出现问题需要断开用RST flag定时器 Connection Establishment Timer：经过这么长时间连接还没成功建立放弃 Retransmission Timer：这么长时间没收到ACK就重发，需要比RTT大，但是在一个数量级。每次重发*2，最多64s Delayed ACK Timer：这个timer timeout前如果要发数据顺便把ACK带回去，如果不发就等到这个timer timeout之后再发ACK Persist Timer：快发慢收的时候，如果收的缓冲区满了，每次这个timer到0问一下缓冲区有空没。时间5～60s，指数退避 Keepalive Timer：KeepAlive连接，每这么长时间问问对面还在不在 Two Maximum Segment Life Wait Timer：关闭连接之后听两个MSL 可以重发没收到的ACK 避免上一个连接的数据包被下一个连接收到 流控：负反馈控制，减少丢包 传输速度限制 接收速度：faster sender slow receiver 网络瓶颈：路由器接收buffer满了只能丢掉数据包 反馈 推测：丢包说明路径上瓶颈不行了 收到反馈 接收方RWND（receiver window）：没被ACK的in flight数据不能超过RWND 路由器反馈丢包，可以建议发送速度 ECN（Explicit congestion notification）ecn 参数 接收方 rwnd（receiver window）：接收buffer还有多少byte可以用，发给发送方 MSS：一个数据包最大多大 发送方 cwnd（congestion window）：本地的变量，不发送，in flight &amp;lt; min(rwnd, cwnd) ssthresh（slow start threshold）：cwnd小于这个数指数增长，大于这个数线性增长 过程 初始状态 ssthresh = 65535 cwnd = MSS slow start &amp;amp; congestion avoidance：每次收到ACK 当 cwnd &amp;lt; ssthresh：cwnd = cwnd + MSS 当 cwnd &amp;gt; ssthresh： fast retransmit：收到三个相同的ACK，不等RTO就重发 fast recovery 收到三个相同的ACK ssthresh = max[2 * MSS, min(cwnd , awnd )/2] cwnd = ssthresh + 3 * MSS 之后每收到一个重复的ACK cwnd = cwnd + MSS 收到一个新的ACK cwnd = ssthresh + segsize 交互式数据流 用于telnet，ssh这种 过程 用户按键 字符发给服务器 服务器将这个字符发回来，同时ACK 客户端在屏幕上展示这个字符，同时给服务器ACK 减少发包 延迟ACK：收到数据包之后等待K ms K ms过程中需要和另一方通信，就顺便把ACK带过去 K ms内没有顺风车，在K ms时发ACK Nagle algorithm 本地cache一小块用户输入，收到服务器ACK之后将cache的输入一块发过去 增加延迟，减少发包 FTPFile Transfer Protocol，服务器20/TCP数据，21/TCP控制，客户算两个动态端口。PORT：PORT的一方想用什么端口，Server和Client都可以PORT模式 passive active多播类型 单播：1对1 多播：1对多，多对多。一个内容的数据包在一个连接上只过一次 广播：1对所有用途 不知道具体目标地址，发给一类目标 eg：路由 发同样的数据给多个host eg：直播关键 地址：所有人都可以给组播地址发，所有IP包会发给组内所有host ip：class d，1110开头，224.0.0.0 ～ 239.255.255.255 预留地址 ipv4 -&amp;gt; mac：不需要ARP ipv4组播固定0x01-00-5e开头 01:00:5e:00:00:00 ~ 01:00:5e:7f:ff:ff 25位是0 后23位是组播IP后23位 class d host id前5位没写进组播MAC 2^5给组播IP共享一个组播MAC：在三层进行过滤 群组管理 IGMP group membership table 对于每个端口，记哪个组播地址有成员在这个端口上 host membership query 路由器发给所有能组播的host（224.0.0.1），TTL 1，60s一次 地址 0.0.0.0 query所有组的成员，也可以query具体一个组 host对每个自己属于的组回复一个 IGMP report 给这个组播地址 随即延迟，大家不一起发 如果收到发给自己组的一个report就不再发了 最开始入组的时候没人问就发一个report 离开组播 v1什么都不做，60s后membership query不回复就离开了 v2可以通知所有路由器 开始发送：flood and pruning 根据RPF flood组播数据 不需要的路由器把自己prune掉 IGMP snooping：部署在二层，一直听query，report和leave消息 知道端口的组播情况 一开始不需要flood数据，减少负载 路由 三个级别 局域网网段：IGMP AS内 DVMRP：Distance Vector Multicast Routing Protocol source based, RPF, flood and pruning MOSPF：Multicast Open Shortest Path First source based CBT：Core based tree group shared，不广播第一个组播包，适合密集组播网络 PIM：Protocol Independent Multicast 同时支持source based和group shared，在group基础上给流量多的source source based AS间：MBGP MBONE：用tunnel连接island。tunnel间p2p，单播数据;island内用上面的方法 路由树 source based：每个一sender一个树 优缺点 流量分布更均匀 每个source发出来的包都走最短路径，延迟小 每个路由器需要给每个source维护一棵树 方法 Dijistra Reverse Path Forwarding（RPF）：从到source的端口将组播包转到所有其他端口 路由表需要稳定 上行和下行需要走同一个线路 否则组播不一定是最短路径 单向连接可能发不过去 group shared：一个组共享一个树 优缺点 组播流量集中 对每个sender不一定是最优的树，延迟大 维护一棵树，开销小 Rendezvous Point的选择影响性能 pruning：收到一个组播包发现没人需要，退出组播树 向上一级发pruning 上一级收到后停止转发，看自己有没有其他需要转发的地方，没有的话继续往上发pruning 应用 DNS：组播query，不能递归query RIPv2：只向RIP路由器发消息 SNMP ICMP：向所有路由器组播路由发现 IP多媒体：直播，游戏IGMPInternet Group Management Protocol，3版功能 加入组播 离开组播（v2） 查询成员 发送成员报告实时服务类别 直播准备好的内容 类似cdn，直接把片子整个推给用户，也可以调进度 直播实时上传内容 实时互动特点 对错误不敏感 延迟敏感 延迟要小 延迟要稳定 否则延迟就要大 " }, { "title": "数据链路层", "url": "/posts/Data-Link/", "categories": "Note, IAP", "tags": "Note, IAP", "date": "2021-11-26 20:36:00 +0800", "snippet": "拓扑类型 点对点网络 PPP 两类帧 Link Control Protocol 建立和配置连接 Network Control Protocol 每个支持的网络层协议都有一个 eg:IP数据包在PPP协议的IPCP里发 - 星型拓扑 一个switch在中间转发所有流量，每条路径上点对点不会冲突 如果switch上出现拥塞，switch可能发假的冲突信号抑制过多流量 广播网络 Medium Access Control：解决碰撞，公平高效地分享介质 Aloha Carrier Sense Multiple Access/Collision Detection (CSMA/CD) 用于Ethernet 可以冲突，冲突了退避 工作过程：信号在介质上传播的最长时间是a 如果介质占用，等到介质空闲 如果介质空闲，立即开始发送 开始发送，开始发送后监听介质2a时间，看是否冲突 最多a时间后发生冲突，最多a时间听到冲突 假设A在介质一端，B在介质另一端，A发送信号后接近a时间B发送，A需要接近2a时间收到冲突信号 如果检测到冲突，发送冲突信号，停止发送，进入指数退避 等待时间槽为2a 冲突第i次，从\\(0～2^i - 1\\)中随机一个数，等待这么多个2a长时间再尝试发送 i &amp;gt;= 10时随机数保持 0～2^10 - 1 连续冲突16次放弃发送 Carrier Sense Multiple Access/Collision Avoidance (CSMA/CA) IEEE 802.11 Wlan：无线一些情况下无法检测冲突，因此要避免冲突 Hidden terminal：(a)中Host A无法知道Host C正在通信，导致冲突 Exposed terminal：(b)中Host C以为信道忙，等着不通信，其实这个时候可以和D通信 两种模式 Infrastructure mode：固定AP，大家都和路由器通信。换ap有专门的hand off方法 ad-hoc mode：host可以组网，转发数据 工作过程 Distributed Coordination Function (DCF) Inter-Frame Space (DIFS) 发送之前随机等待一段时间，如果信道一直空闲开始发送 如果要发送时信道占用 等到发送完毕 等DIFS 之后等退避时间。退避过程中如果信道占用暂停计时，等到计时完毕尝试发送 Request to Send / Clear to Send：解决hidden terminal问题 发送前发RTS，带上需要占用信道的时间 目标空闲回CTS，所有能和目标通信的host都会收到CTS，这段时间就算介质空闲也是占用的 传输完成后回复ack MAC地址不同的数据链路层协议不同。Ethernet地址48位，全球唯一 前24位：vendor component，每个生产商一个 第八位标记multicast 后24位：group identifier，每个设备不同ARPAddress Resulution Protocol 将网络层地址转成数据链路层地址 不同的网络/数据链路层用不同的地址，ARP有不同的组合 L2协议，ARP帧永远不会过路由器 Proxy ARP是路由器在另一个冲突域代发的 ARP Table每条记录通常20min过期。每当设备收到ARP帧，会首先将其中的IP&amp;lt;-&amp;gt;MAC对应关系写到ARP Cache里。内容 IP MAC Flag permanent：手动配置的记录不会过期 pub：host会回复找这条MAC的IP incomplete：发了request没回复 帧格式长度：28 Bytes（IP V4 &amp;lt;–&amp;gt; MAC，不同协议长度不同）。发的时候如果放在Ethernet帧中，最短要求46 Bytes，有18 Bytes的pad Hardware Type：数据链路层地址类型 Protocol Type：网络层地址类型。比如IP 0x0800 Hardware length：数据链路层地址长度 Protocol length：网络层地址长度 Operation：操作类型。1 ARP Request，2 ARP Reply，3 RARP Request，4 RARP Reply。 Sender hardware address：发送者数据链路层地址 Sender protocol address：发送者网络层地址 Target hardware address：目标数据链路层地址 Target protocol address：目标网络层地址过程L3下来的数据包需要L2转发时 查ARP Table看有没有这个IP对应的MAC 如果没有广播一个ARP Request，SHA和SPA写自己的MAC和IP，TPA写目标IP，THA在Request中会被忽略 目标设备收到一个TPA == 自己IP的ARP Request，单播一个ARP Reply到发送的设备，把自己的MAC写到THA中，之后把Target和Souce对换Proxy ARP 两个host实际是在不同的冲突域，但是IP/子网掩码配置让他们觉得自己是一个网段，会发ARP。 Proxy ARP是路由器代替主机回ARP请求，THA是目标host IP，TPA是路由器端口IP。 可以向外部屏蔽局域网细节，可以用于NAT 路由器在收到包之后会用L3的信息转发，一个端口可以代理多个hostGratuitous ARPSender和Target信息都是Sender信息的广播ARP帧可以用于 向局域网广播自己MAC地址的变化 新加入网络时检查自己的IP是否已经被占用MTU数据链路层中每个帧中最大的Payload长度，不算自己的协议头和尾 Ethernet，PPP：1500 Bytes FDDI：4352 Bytes PPP（低延迟）：296 BYtes Ethernet Jumbo Frame：9000 BytesPath MTU Discovery：找到路径上所有二层连接里最小的的MTU 设置IP Flag中的Don’t Fragment 发一个大数据包，等ICMP Unrechable Payload里有MTU of next-hopDestination Unreachable - Fragmentation required, and DF flag setBridgeIEEE 802.1d 网桥 从一个冲突域向另一个冲突域转发数据包。进出协议相同时帧完全不会被修改 如果两个冲突域协议不同，网桥可以做翻译优点 大规模局域网可以在bridge之间拉p2p骨干，之后bridge连多个设备，增加局域网距离 扩大局域网规模 分割冲突域，减少冲突 更安全，设备只能看到自己冲突域的信息数据转发Filtering table：记MAC所在的端口 目标MAC 设备所在端口 TTL：默认300s地址学习：收到一个数据包就记录下发送者MAC和收到的端口转发：查Filtering table 找到了MAC：转发到所在端口 找不到：转发到收数据包端口外的所有端口生成树协议环的危害 广播风暴：一个环中所有网桥都不知道往哪转的数据包会被一直转发，占用大量带宽 不一定是广播，只要所有网桥都不知道往哪发就会flood，造成风暴 Filtering table震荡：对于Bridge 1和Bridge 2，Host 1一直是一会在LAN A一会在LAN B，正常的数据包可能也会转到错误的地方并丢失解决：去除拓扑中的环 -&amp;gt; 生成树协议关键概念 Port ID：2 Bytes，1 Byte 优先级 + 1 Byte 端口号 Bridge ID：8 Bytes，2 Bytes 优先级 + 6 Bytes MAC -&amp;gt; 网桥中端口号最小的端口MAC Root Bridge：拓扑中Bridge ID最小的网桥 Root Port：每个非根网桥到根网桥代价最小的端口，代价相同选Port ID小的 代价可以是跳数，带宽。。。 Root Path Cost：根端口到根网桥的代价 Designated Port：一个LAN上到根网桥代价最小的端口 两个网桥有代价相同的端口，选BID小的 一个网桥两个端口代价相同，选PID小的 Designated Bridge：一个LAN Designated Port所在的网桥建树 找BID最小的网桥 找每个网桥到根网桥代价最低的端口 代价相同选PID小的 找每个LAN所有端口里到根网桥代价最小的 两个网桥代价相同选BID小的 两个端口代价相同选PID小的 所有的根端口和指定端口转发数据，其他所有端口block，只发BPDU这种控制信息收敛 所有网桥往出发BPDU，当自己是根网桥 比较收到的所有BPDU，如果有更小的把人家当根网桥，继续发BPDU，每个端口发出的BPDU是不完全一样的 发BPDU 收到更小的根网桥 拓扑发生改变 一个端口可以听一个LAN里所有端口的BPDU，自己是不是指定端口就有B数了 一个网桥综合所有端口收到的BPDU选自己的根端口 除了根端口和指定端口，block所有其他的注意 根网桥不一定全是指定端口，可能一个LAN上有两个端口，要block一个" }, { "title": "Arch Linux安装", "url": "/posts/Arch-Install/", "categories": "Linux", "tags": "Arch", "date": "2021-09-10 00:00:00 +0800", "snippet": "Arch是一个十分干净简洁的Linux发行版，日常使用不吃硬件十分流畅。采用滚动更新方式，安装之后更新就行，没有类似重装的升级，个人感觉很适合实验室这种多人共用机器的场景。Arch的社区可能是一众Linux发行版中最好的。Arch Wiki基本能解答所有系统相关的问题，里面的内容对于一些Arch下游的Linux发行版(比如Manjaro)也是有用的。AUR(Arch User Respository)提供了大量的软件安装脚本，基本上装所有的东西都只需要一行命令。总结起来就是简单且强大。下文所有折叠的块都是可选步骤，主要包括ssh连接，mdadm raid和btrfs文件系统，不需要的话直接跳过。 折叠块长这样 折叠起来的都是可选步骤，不需要直接跳过硬件需求 CPU：x86架构，绝大多数电脑都是。Arch有专门的ARM版本 RAM：512M以上 硬盘：2G以上 网：wifi就行，查网线更简单 U盘：做虚拟机不需要。8G肯定够用，镜像不到1G。读写速度主要影响做启动盘的时间，安装过程中联网下载比较多，从U盘中读写比较少isoArch官方镜像列表里有所有的iso下载地址，国内从清华源下一般比较快。文件名是 archlinux-年月日-x86_64.iso，蓝色那行做虚拟机不需要做启动盘，直接用iso。在物理机器上装，Etcher非常适合做任何Linux发行版的安装盘。使用简单，大都一次成功。选盘的时候注意，别选错了！！！否则可能把正在用的盘格掉。Etcher一般会把不像U盘的设备折叠起来，一般会是最小的一个盘，仔细看一眼肯定不至于选错。即使手上有之前的启动盘也建议做一个新的，Arch更新比较频繁，用旧的启动盘可能会出一些软件兼容的小问题，最新的镜像可以避免麻烦。开始安装插入做好的启动盘，重启电脑选择U盘作为启动媒体，一般是按住F1，F2, F5，F10，F12中的一个键时候按电源键。启动后选择Arch Linux install medium。之后会进到一个命令行，开头的提示符是root@archiso，如下todo live字体 terminus fontsetfont ter-132n键位国内的键盘一般都不需要改键位，如果需要可以参考官方教程locale-ctl list-keymaps | grep [键盘布局缩写]loadkeys [键盘布局名]联网安装过程中需要联网下软件。可以ping一个网站检查网络连接ping baidu.com# ctrl c 停止如果看到 Name or service not know之类的报错就是目前没网。直接插网线最简单，不需要进行额外操作。连wifi Arch推荐用iwctl。iwctl device list # 列出所有网络接口ip link set [网络接口] up # 我的叫 wlan0。先打开硬件，关闭硬件是downiwctl # 进入iwctldevice list # 列出所有网络接口，一般会有一个lo是环回的，不是这个。需要用的设备大概叫wlan0station [网络接口] scanstation [网络接口] get-networks # 获取所有wifistation [网络接口] connect [wifi name] # 之后输密码quit # 退出iwctl连接完成重新ping一下，这时候应该看到能ping通。连接8021x校园网1 2ssh 可选步骤。用另一台电脑ssh到正在装的电脑上可以复制命令，方便一点 启动盘的live系统不能复制，一些命令手打比较麻烦。可以考虑用另一台机器ssh到要安装的机器上，方便一点。 # pacman -Syy openssh # 安装ssh，最新的arch iso已经带openssh了，不需要装 systemctl start sshd # 启动ssh服务 passwd root # 给root设置密码 ip a # 查看机器ip # 在另一台机器上 ssh root@[上面ip a看到的ip] 硬盘分区硬盘上创建了文件系统才能用。首先检查电脑是不是用了uefils /sys/firmware/efi/efivars如果说没有这个路径那就是没用uefi，下面分区的时候跳过uefi分区的部分。如果像下图一样出了一堆文件就是用了uefi，需要做一个uefi分区。除了uefi分区至少还需要一个root分区，一般还会做一个swap。一些特殊用途的系统比如服务器可能/srv或者/var下会存巨多的文件，这样可以给这个路径单开一个分区放到一个比较大的盘上，这个过程和做root分区是相同的。这个教程就做三个分区：uefi，root和swap。lsblk # 查看机器硬盘情况这里sda是U盘启动盘，nvme0n1和nvme1n1是ssd。进入gdisk开始创建分区gdisk /dev/[盘号] # 注意这块就写到盘，不要写到分区p1p2这种的d # 之后打一个数字分区号删除它，多次执行直到提示没有分区首先做efi分区，如果上面没有uefi就跳过这段，直接创建下面的主分区n # 创建分区# 回车，默认分区号# 回车，默认起始位置+512M # 大小512Mef00 # 修改分区类型为efi分区创建主分区n # 创建新分区# 回车，默认分区号# 回车，默认起始位置-8G # 这个8G就是给swap留下的大小，一般swap跟内存大小相同。如果有两块盘可以都做一个swap分区，分别内存一半大小# 回车，分区类型默认就是Linux文件系统创建swapn# 回车，默认分区号# 回车，默认起始位置# 回车，直接占满剩下的容量8200 # Linux swap分区创建完成，看一下目前磁盘情况，应该有三个分区，类型分别是EFI，Linux和Linux swap。p如果没问题就把修改写入磁盘w # 确认无误后写入Y # 确认lsblk # 再次查看分区情况之后需要在分区上创建文件系统# mkfs.vfat /dev/[uefi分区] # 没有uefi分区跳过这行mkfs.fat -F32 /dev/[uefi分区] # 没有uefi分区跳过这行mkswap /dev/[swap分区]swapon /dev/[swap分区]# swapon 也可以写多个swap分区，比如 swapon /dev/nvme0n1p2 /dev/nvme1n1p3，这样多个swap分区应该会像raid 0一样做stripping加快速度主分区文件系统有三种选择，绝大多数情况下最简单的ext4是最合适的，跑下面这一行之后直接到安装Arch一节就可以。mkfs.ext4 /dev/[主分区]如果想提升一点读写速度可以做软件raid，如果想要snapshot功能可以用btrfs文件系统。Raid 可选步骤。软件Raid可以提升一些读写速度 之前在搜教程的时候看到一个Arch + Raid 0经验贴下面的的评论，笑了一下午。必须放在这 /笑哭 个人在存储技术方面可以说没有任何经验，下面的背景部分只是记录一些自己在调研过程中的理解和想法。 基础的软件Raid大概有两条路线，一种是基本的ext4文件系统+软件Raid+逻辑卷管理，另一种是直接用zfs，btfs这种带Raid支持的文件系统。就我的在2块SSD的笔记本上加快读写速度的场景下似乎第一种更合适。 网上冲浪的过程中感觉btfs风评差很多，在Raid这种追求持续在线和稳定的用例下开发团队似乎并不重视软件质量。评价用btfs不是会不会丢数据的问题，只是什么时候丢数据。zfs功能很多，除了自带Raid以外copy on write带来的灵活创建备份点和快速格式化很大的存储听起来很有用。不过不是做NAS盘比较小ext4还能应付，我也没有备份系统的习惯最多备份文件，所以功能上二者没有决定性的差别。而且因为开源协议的问题zfs不能合进linux内核，自己做iso比较耗时间。综上选了第一条路线。 Raid的实现分为三大类：硬件Raid，软件Raid和主板Raid(fakeraid)。硬Raid用专门的芯片和独立于uefi的固件实现，性能最好，对主板固件和操作系统来说一个硬Raid的阵列就是一块盘。软件Raid和fakeraid都依赖CPU进行运算，理论上性能差别不是很大，一般没有硬件Raid就会采用软件Raid，fakeraid没人推荐。Raid有多种级别，具体可以参考这篇。笔记本大概就是Raid 0 和 Raid 1,主要着眼提速，Raid 0 用一倍的故障率换速度，Raid 1 用一半的空间换容错。我做的是Raid 0不过其他级别流程上区别不大。 做Raid要分区，因为就算一个厂商一个型号的盘大小也会有一些不同。如果阵列有容错，换盘的时候软件Raid要求换进来的盘和之前的盘大小完全相同。如果直接用整块盘做Raid，之前的盘还偏大就很不巧了。 做Arch至少要两个，一般有三个分区，分别是uefi，主分区和可选的swap。软件Raid依赖操作系统，而uefi分区在进操作系统之前就要用，所以这个分区要么不Raid要么Raid 1。linux支持多个swap，如果有两个swap在两个盘上默认就会用类似Raid 0的方式读写，所以swap也没必要放进Raid。这样就只需要给系统分区做Raid。如果继续对系统分区细分，只想对存数据的部分进行Raid安装过程和不配Raid完全相同。系统做完之后配Raid挂载就可以。 废话结束，综上我的两块SSD Raid 0分区布局如下 SSD 1 UEFI分区：512M 系统分区：剩下的空间取个整数 swap分区： 1/2 swap大小 SSD 2 系统分区：和SSD 1上的系统分区一样大 swap分区： 1/2 swap大小 格盘的细节参考下一节，记一下mdadm的内容 # 删除旧记录 mdadm --misc --zero-superblock /dev/drive # 创建Raid 0 mdadm --create /dev/md0 --level=stripe --raid-devices=2 /dev/drive[1-2] # 或者盘分开写 mdadm --create /dev/md0 --level=stripe --raid-devices=2 /dev/drive1 /dev/drive2 # 查看mdadm运行状态，raid细节 cat /proc/mdstat mdadm -E /dev/drive[1-2] mdadm --detail /dev/md0 Raid做完之后如下步骤，替换成自己的设备文件 在分区1上 mkfs.fat -F32 /dev/[uefi分区] 在分区3和5上分别 mkswap /dev/[swap分区] swapon /dev/[SSD 1上的swap分区] /dev/[SSD 2上的swap分区] 在md0里创建一个ext4分区，mkfs.ext4 /dev/raid 0里的分区，后面mount的时候也mount这个分区 Raid部分已经跑起来了，在挂载主分区之后，arch-chroot之前和之后还有几行命令需要执行。btrfs 可选步骤。Btrfs提供raid和快照功能，做起来比较复杂不推荐新手用 btrfs和ext4一样是一个文件系统，负责管理存在盘上的文件。btrfs应该只有一个竞品zfs，这两个文件系统融合了传统解决方案ext4+软件Raid+逻辑卷管理的大部分功能。主要的优点是提供快速和不怎么占额外空间的snapshot，此外可以做跨盘的文件系统并开启raid。总体上来说速度更快，功能更多。个人在用btrfs的过程中还没遇到什么大问题，但是和zfs相比btrfs风评差很多，主要是因为bug比较多可能丢数据，而且开发者社区貌似赶不上zfs。但是zfs因为开源协议冲突不能合入linux内核，安装过程比btrfs麻烦一些。研究明白btrfs之后这篇会加做zfs的过程。 上一节已经做好了root，uefi和swap三个分区，这里从mkfs.btrfs开始。类似逻辑卷，btrfs的文件系统可以跨盘，详情参考btrfs wiki，下面是官方给的一些常用例子 # Create a filesystem across four drives (metadata mirrored, linear data allocation) mkfs.btrfs -d single /dev/sdb /dev/sdc /dev/sdd /dev/sde # 简单跨盘，不raid # Stripe the data without mirroring, metadata are mirrored mkfs.btrfs -d raid0 /dev/sdb /dev/sdc # 相当于raid0 # Use raid10 for both data and metadata mkfs.btrfs -m raid10 -d raid10 /dev/sdb /dev/sdc /dev/sdd /dev/sde # Don&#39;t duplicate metadata on a single drive (default on single SSDs) mkfs.btrfs -m single /dev/sdb 比如我的两块ssd raid mkfs.btrfs -f -d raid0 /dev/nvme0n1p1 /dev/nvme1n1p2 做好btrfs文件系统之后就是挂载和创建子卷。这里的子卷结构是Arch Wiki的推荐加上一点个人理解。 直接用btrfs创建和管理快照比较麻烦，openSUSE社区的snapper比较推荐。snapper在快照的时候不会包含子卷里挂的子卷。根目录必须是一个子卷，所以如果其他子卷挂在根目录下，快照根目录子卷只会包含根目录里不是子卷的目录，这些根目录下的子卷需要分别创建快照，比较麻烦。综上用的子卷结构是整个系统基本上都直接扔到根目录的子卷里，给不希望回滚的目录单独创建子卷挂上去。比如数据库的数据一般在/var目录下，ftp和web的文件一般在/srv下，显卡驱动一类第三方软件一般在/opt下，临时文件一般在/tmp下。这样快照+回滚的时候不会影响到这些子卷里的内容。 特殊一点的是快照和swap，快照需要单独用一个子卷，否则会快照到快照。btrfs不支持快照swap文件，所以单独开一个子卷放swap文件，不一定用得上，但是反正他也不占地方。之后把home目录单独做子卷拿出去。整体结构如Arch wiki的这个图 todo 研究snapper alternative 开干 part_name=[btrfs的任意一个分区名字] mount /dev/${part_name} /mnt # ${part_name} 是bash变量，前面写的 [btrfs的任意一个分区名字] 会被放到 ${part_name} btrfs subvolume create /mnt/@ btrfs su cr /mnt/@home btrfs su cr /mnt/@swap # swap文件推荐放进单独的子卷 btrfs su cr /mnt/@.snapshots 挂载子卷，一些参数的解释 noatime： 不写accesstime，速度更快 compress： zlib最慢，压缩最率高；lzo最快，压缩率最低；zstd和zlib兼容，压缩率和速度适中，可以调压缩等级 space_cache=v2：将文件系统中空闲的block地址放在缓存里，创建新文件的时候可以立即开始往里写 nodatacow：禁用cow，新数据直接覆盖 ssd：开启针对ssd的优化 discard=async：大概是异步进行trim，可以降低读延迟 umount /mnt mount -o noatime,compress=lzo,space_cache=v2,ssd,discard=async,subvol=@ /dev/${part_name} /mnt mkdir /mnt/{home,swap,.snapshots} mount -o noatime,compress=lzo,space_cache=v2,ssd,discard=async,subvol=@home /dev/${part_name} /mnt/home mount -o noatime,compress=lzo,space_cache=v2,ssd,discard=async,subvol=@.snapshots /dev/${part_name} /mnt/.snapshots mount -o nodatacow,ssd,subvol=@swap /dev/${part_name} /mnt/swap 安装Arch安装需要联网下载，选一个快的镜像可以节省很多时间pacman -Syy # 更新pacman数据库pacman -S reflectorcp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bk # 备份镜像列表reflector -c &quot;CN&quot; -l 20 -n 10 --sort rate --save /etc/pacman.d/mirrorlisttodo 检查bash-completionmount /dev/[主分区] /mnt # 挂载主分区pacstrap /mnt base linux linux-firmware linux-headers vim base-devel opendoas grub efibootmgr gitgenfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstabcat /mnt/etc/fstab Raid 把mdadm配置写入文件 mdadm --detail --scan &amp;gt;&amp;gt; /mnt/etc/mdadm.conf 切换到新装好的系统arch-chroot /mnt btrfs pacman -S btrfs-progs grub-btrfs vim /etc/mkinitcpio.conf # MODULES=(btrfs) mkinitcpio -p linux systemctl enable fstrim.timer Raid 在新系统里装mdadm，和修改一个配置文件。Raid所有配置完成，下面正常安装就行。 pacman -S mdadm vim /etc/mkinitcpio.conf HOOKS=(base udev autodetect keyboard modconf block mdadm_udev filesystems fsck) # 在HOOKS这行添加 mdadm_udev mkinitcpio -p linux 校准时间# timedatectl list-timezones # 显示所有时区，按q退出# ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localetimetimedatectl set-timezone Asia/Shanghaitimedatectl set-ntp true # 开启联网时间校准hwclock --systohctodoecho “KEYMAP=[键盘布局]” » /etc/vconsole.conf语言vim /etc/locale.gen# 按 / 进入查找，输入en_US，回车下一条结果# 找到 en_US.UTF-8 UTF-8 这一行# 按i编辑，删除前面的 ## 按两次esc进入命令模式# 按 / 进入查找，输入zh_CN，回车下一条结果# 找到 zh_CN.UTF-8 UTF-8 这一行# 按i编辑，删除前面的 ## 两下esc，输入:wq保存退出locale-genecho LANG=en_US.UTF-8 &amp;gt; /etc/locale.conf设置网络hostname=[随便选一个hostname] # 不建议用自己的名字之类的个人信息，这个至少局域网里是能看到的echo ${hostname} &amp;gt;&amp;gt; /etc/hostnamecat /etc/hostnameecho &quot;127.0.0.1 localhost::1 localhost127.0.0.1 ${hostname}.localdomail ${hostname}&quot; &amp;gt;&amp;gt; /etc/hosts安装grubuefi系统mkdir /boot/efimount /dev/[uefi分区] /boot/efigrub-install --target=x86_64-efi --bootloader-id=GRUB --efi-directory=/boot/efi # 注意那个x是小写的grub-mkconfig -o /boot/grub/grub.cfg非uefi系统pacman -S grubgrub-install /dev/[主分区]grub-mkconfig -o /boot/grub/grub.cfg设置密码passwd ＃ 设置密码网络前面设置的网络连接只在这次安装过程中生效，还需要给刚装好的系统装联网软件。下面只写基本的连接wifi的部分，DSL，移动网络之类的连接可以参考这篇详细教程pacman -S wpa_supplicant wireless_tools networkmanager network-manager-appletpacman -S nm-connection-editorsystemctl enable NetworkManager.servicesystemctl disable dhcpd.service # 如果说dhcpd not found也没关系，目标就是把他关了systemctl enable wpa_supplicant.service这里就可以重启进入只有命令行的系统了，可以选择现在重启看一下前面的步骤是不是做的有问题，下面的步骤在进入系统后做，或者也可以不重启直接继续装。添加用户一般日常使用不会直接用root账户，创建一个用户帐户。username=[用户名]useradd -m ${username}# 添加一行echo &quot;permit persist ${username} as root&quot; &amp;gt;&amp;gt; /etc/doas.conf # 允许 用户名 作为root执行，persist是输入一次密码之后一段时间不用再输入mv /usr/bin/sudo /usr/bin/sudo-bkln -s /usr/bin/doas /usr/bin/sudopasswd ${username} # 设置新用户密码桌面 Btrfs snapshot 桌面会装很多包，如果用了btrfs，可以在安装桌面之前做一下snapshot。详细步骤参考这里xfce4lightdm-slick-greeterpacman -S xorg xfce4 xfce4-goodies lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settingssystemctl enable lightdm220多个包KDEpacman -S xorg plasma plasma-wayland-session kde-applicationssystemctl enable sddm.service800多个包有时候新安装桌面可能遇到登录循环的情况，开机后正常输入用户名密码，结果回车登录之后又回到输入密码界面。这种情况可能是因为没有 /home/[用户名] 目录或者用户没有这个目录的权限，创建试一下。mkdir /home/[用户名]chown -R [用户名]:[用户名] /home/[用户名]安装完成，重启进入系统# 按 ctrl+D 退出 chrootreboot重启之后应该就能看到一个登陆界面，登陆进去看到桌面就是安装成功了！如果安装过程中有任何问题欢迎在下方留言。有关一些常用软件的安装在下一篇文章中记录。参考资料：官方安装教程Arch安装教程 (不带swap)安装教程 (带swap)iwctl连接wifimdadm+archArch RaidArch Linux BTRFS Install" }, { "title": "部署个人Git", "url": "/posts/Git/", "categories": "Host, Git", "tags": "Git, Gitea, SelfHost", "date": "2021-02-07 19:02:00 +0800", "snippet": "Github是全球最大的开源社区，一般把自己的开源项目放到Github上可以让更多开发者看到，也不用担心项目丢失。但是一些场景下可能也会希望自己部署Git，比如在国内访问Github一般很慢，如果希望频繁地push和pull那么在国内租服务器架上Git速度可以快上几百倍；看往网上的评价如果希望使用一些CI/CD功能，可能Github不支持或者收费，这时候自己部署更灵活或者可以降低成本。这个Post记录自己安装Gitea，Gogs和GitLab的过程，(目前主要发现这三个比较方便的方案，后期发现其他会继续添加)以及一些体验感受。GiteaGitea由Golang编写。安装步骤基本按照这篇教程。# 升级系统并安装必要的包yum updateyum install -y wget git epel-release tree# 给gitea服务添加用户和存项目的目录useradd gitmkdir -p /etc/gitea /var/lib/gitea/{custom,data,indexers,public,log}chown git:git /var/lib/gitea/{data,indexers,log}chmod 750 /var/lib/gitea/{data,indexers,log}chown root:git /etc/giteachmod 770 /etc/gitea# 查看刚创建的目录tree /var/lib/gitea//* /var/lib/gitea/├── custom├── data├── indexers├── log└── public */# 安装数据库yum install -y mariadb-serversystemctl enable mariadbsystemctl start mariadbmysql_secure_installation # 给root设密码，之后一通 y 就行# 登录数据库建表mysql -u root -pcreate database gitea;grant all on gitea.* to gitea@localhost identified by &#39;Gitea Password&#39;;flush privileges;quit下面就是安装Gitea，可以先到Release页面看一下最新的版本，把版本号写到下面的变量里。这步不是必需的，会不定期更新下面这个版本号# 下载giteaexport GITEAVER=1.13.2wget https://github.com/go-gitea/gitea/releases/download/v${GITEAVER}/gitea-${GITEAVER}-linux-amd64 -O /usr/local/bin/giteachmod +x /usr/local/bin/giteagitea -v# 创建 gitea 服务echo &quot;&quot;&quot;[Unit]Description=GiteaAfter=syslog.targetAfter=network.targetAfter=mariadb.service[Service]RestartSec=2sType=simpleUser=gitGroup=gitWorkingDirectory=/var/lib/gitea/ExecStart=/usr/local/bin/gitea web -c /etc/gitea/app.iniRestart=alwaysEnvironment=USER=git HOME=/home/git GITEA_WORK_DIR=/var/lib/gitea[Install]WantedBy=multi-user.target&quot;&quot;&quot; &amp;gt;&amp;gt; /etc/systemd/system/gitea.servicesystemctl daemon-reloadsystemctl start giteasystemctl status gitea到这里安装基本结束了，访问 http://服务器地址:3000/install 应该就能看到初始化配置的界面。如果是按照上面的步骤安装的应该只需要修改数据库密码之后就可以使用了。GogsGitlab" }, { "title": "Atom编辑器配置", "url": "/posts/Atom/", "categories": "Tool", "tags": "Atom, IDE", "date": "2021-01-13 12:56:08 +0800", "snippet": "Atom是Github开发的一个文本编辑器，十分简洁，基本只内置了文字编辑，Git，语法高亮这些最核心的功能，可以通过插件灵活扩展。目前我的Atom主要用于Python和Web开发，写Markdown，远程代码编辑等。这个Post记录Atom的配置，主题，插件等方面的内容。首先从官网下载Atom安装包安装。apmAtom安装主题和插件用的都是apm(Atom Package Manager)，每一个插件都是一个npm包，国内大概率下载会比较慢。可以通过换源或者代理进行加速。# 换源npm config set registry https://registry.npm.taobao.org # 设置淘宝镜像npm config get registry # 查看是否设置成功# 代理apm config set https-proxy &quot;http://127.0.0.1:6666&quot; # 设置proxyapm config delete https-proxy # 取消proxyapm默认大概安装到 ~/.atom/packages/ 路径下，不同安装进程之间不冲突，可以开多个terminal一起装多个包，也可以将所有要装的包写入一个文件批量安装。大多数包安装完都需要重启atom生效。基础配置主题这个完全看个人喜好，因为需要长时间看屏幕很喜欢暗色的主题，默认的 one-dark 觉得就不错。这里是一个完整的列表。文件缩略图对于比较复杂的项目(比如一个网站)，一般会有多种格式的文件，这样能一眼看出文件类型应该有些用处。 file-type-icons 给不同类型的文件不同的图标，看起来比较清(zhuang)楚(bi)。小地图打王者要看小地图，写代码有时候看一下也挺方便的。比如装上 minimap ， highlight-selected 和 minimap-highlight-selected 之后，选中一个变量，这个变量在代码中所有出现的位置都会在小地图上高亮，看起来很方便。代码段补全对于一些经常要写的格式化内容很有用，Atom支持对指定拓展名的文件自定义模板。编辑 ~/.atom/snippets.cson 文件，以添加一个Jekyll文章开头的yaml为例。&#39;.md&#39;: &#39;jk head&#39;: &#39;prefix&#39;: &#39;jk&#39; &#39;body&#39;:&#39;&#39;&#39;---title: ${1: Default Title}author: Lin Handate: +8categories: []tags: []math: true---&#39;&#39;&#39;.md代表这个模板只在.md文件中生效；jk head 是补全列表里显示的标题；prefix是你打出这个字符串就进行这个联想；body部分如果只有一行，’内容’ 这种单引号引起来就可以，这里因为是需要多行所以是 ‘’’这样 ’’’的。内容部分可以写$1，${2:default}这样的光标位置，而且可以带默认值。一个单行的例子，用于在md文件中插入不会被render的TODO&#39;.md&#39;: &#39;todo&#39;: &#39;prefix&#39;: &#39;todo&#39; &#39;body&#39;:&#39;[//]: # (TODO:$1)&#39;重启Atom生效字体默认的字体可能不是很好看，fonts插件里有146个字体和变种，用起来很方便。Python补全个人还是比较喜欢用补全的，有的时候是想不起来的函数名，有的时候打到剩最后一个字母补全能防止打错。如果装的话 autocomplete-python 是个不错的选择，支持本地的Jedi和联网的Kite。如果你是刚开始写 Python ， Kite应该会很贴心。代码格式和检查如果是初学比较建议进行格式化，刚开始写很容易养成好的代码习惯，自己看着清楚，别人看着也舒服。很多 Linter 都是带格式化的，但是看好多人都推荐 python-black ，其实各种 Formatter 差别都不是很大。linter-flake8 是 Linter，就是带格式检查的，比较受欢迎，但是个人感觉不是很需要，一 save 一堆 Error 很分心。IPython交互式运行比较方便，但是也容易有不少问题，比如 import ，运行的路径和运行的环境之类。我是不想整明白这些，但是如果要用，Hydrgoen 是个不错的选择。注释复杂的代码不写注释绝对是犯罪， docblock-python 是一个很方便的自动生成函数注释的工具依赖一个Py项目总是需要很多包，python-requirements可以自动搜索项目中所有import了的包，生成requirement.txt。缩进转换个人写代码喜欢用tab，但是复制的其他人的代码可能是4个空格。Atom可以一键调整所有的 tab 和空格，Ctrl-Shift-P 调起类似cmd的窗口，输入 tab to space 或者 space to tab 可以换当前页面所有的tab或space。远程编辑如果你只是本地编写代码本地跑那这个没啥用，但是比如你跑深度学习或者写个服务器上运行的脚本，需要本地写代码服务器上运行，那么远程修改就挺有用。ftp-remote-edit这个包用了一下，效果不错。Markdownlanguage-markdown提供md的高亮，缺这个包所有内容都是一个颜色。Atom架构开放，大量的插件给Markdown编辑带来了丰富的功能。内容结构document-outline 可以在页面右侧显示文章标题结构，方便看到全局，对长内容很有用。预览直接看着代码写显然不够直接，HTML预览是刚需。 Atom自带一个markdown-preview，但是功能比较少。markdown-preview-plus 功能丰富一些，可以对内容进行预览，实时编译。这个包默认代码和预览不会一起滚，在设置中可以开启滚动同步。开关preview的快捷键是，Ctrl-Shift-M。数学公式的符号是可以设置的，比如默认有一个$框起来的认为是公式，可以添加两个 $$ 。这个插件最令人伤感的地方是预览不能放到另一个Atom程序中，我没研究出怎么一个屏幕编辑代码，一个屏幕看预览。多合一markdown-writer 简直是写md必装，针对Jekyll等几个博客系统有专门的功能，方便创建Post，管理tag和category(这几个脚本创建tag和category list)，插入图片等等，功能十分强大。可以在repo里写配置文件，这样设置可以跟着项目一起走。设置详见。在用Jekyll时发现一个问题，Jekyll项目所有 _ 开头的文件夹里面的东西都不会放到Render后的网站里。插入图片时希望图片可以按照文章进行组织，一篇文章的图片都放在一个文件夹。但是用{directory}参数把文章相对项目的路径包含进去路经里会有 _post ，导致所有的图片都不进到最后的 _site 中。设置中好像没好的解决方案，直接修改了插件代码把这个字符串滤掉了。首先atom打开插件的文件夹 ~/.atom/packages/markdown-writer/，之后在整个项目中搜索(先点一下左边的根目录，之后Ctrl+Shift+F)下面的代码siteImagesDir: -&amp;gt; templateHelper.create(&quot;siteImagesDir&quot;, @frontMatter, @dateTime)应该一共有两处，一个是从剪贴板添加，一个是从文件添加。替换成下面的siteImagesDir: -&amp;gt; templateHelper.create(&quot;siteImagesDir&quot;, @frontMatter, @dateTime).split(&quot;_posts&quot;).join(&quot;&quot;).split(&quot;_drafts&quot;).join(&quot;&quot;)在插入图片时就不会有带 _ 的路经了。用绝对路经前面会少一个 / ，可以在上面两个脚本里找到这一行generateImageSrc: (file) -&amp;gt; utils.normalizeFilePath(@_generateImageSrc(file))修改成generateImageSrc: (file) -&amp;gt; &#39;/&#39;.concat utils.normalizeFilePath(@_generateImageSrc(file))修改完成后可以 Ctrl+Shift+P 调起命令框，打 reload 之后回车让Atom重新加载，这样不需要重启Atom也可以让对插件的修改生效。markdown-writer所有可以通过atom命令行调用的功能都可以定义快捷键。添加快捷键首先按 Ctrl+Shift+P 调起atom的命令行，输入 Markdown Writer: Create Default Keymaps，回车，就会生成一个定义快捷键的文件。可以进行修改，保存后reload或者重启atom就生效了。//: # (TODO:完善快捷键)表格在md中写表格经常会遇到一些格式问题，markdown-table-editor插件可以自动处理一些表格格式。快捷键跳转Ctrl - G 跳转到制定行，报错有行号直接用这个找过去。Ctrl - R 会打一个函数名的列表，选哪个跳转到哪个函数。Ctrl - Shift - F 可以全项目搜索。脚本批量安装apm支持从文件中读取包名批量安装echo &quot;highlight-selectedminimapminimap-highlight-selectedfile-type-iconspython-blackdocblock-pythonlanguage-markdowndocument-outlinemarkdown-preview-plusmarkdown-writerpretty-jsonmarkdown-table-editorfontsclang-format&quot; &amp;gt; apm_install_list.txtapm install --packages-file apm_install_list.txtrm apm_install_list.txt代码块echo &quot;&quot;&quot;&#39;.md&#39;: &#39;todo&#39;: &#39;prefix&#39;: &#39;todo&#39; &#39;body&#39;:&#39;[//]: # (TODO:$1)&#39; &#39;ref&#39;: &#39;prefix&#39;: &#39;ref&#39; &#39;body&#39;:&#39;[//]: # (REF:$1)&#39;&quot;&quot;&quot; &amp;gt; ~/.atom/snippets.cson彻底删除重装rm -rf ~/.atomyay -S atom问题记录一些在使用Atom过程中遇到的问题keyringAtom应该是要把一些敏感信息存到keyring里，如果最开始创建了keyring，Atom用上了。之后有一次Atom弹窗要你输入keyring密码但是你没有，打开下一个Atom窗口可能出现能正常显示文件树，但是点击文件不能看到内容。git能点push但是永远也push不上去，Github的tab一直在转圈。这个情况可以直接废掉之前的keyring重新创建一个。但是要注意Atom不一定是唯一的用keyring的软件，浏览器可能也需要。在Arch下可以mv ~/.local/share/keyrings ~/.local/share/keyrings-bk之后Atom找不到keyring下次打开就会要你重新创建了。" }, { "title": "Centos环境配置", "url": "/posts/Centos-env-setup/", "categories": "Linux", "tags": "Centos", "date": "2021-01-05 23:22:16 +0800", "snippet": "Centos是基于RedHat Enterprise Linux开源的一个Linux distro，以极高的稳定性闻名。这个Post讲解将Centos作为服务器，安装软件和进行配置的技巧。虚拟化一些软件（比如mailcow）可能会对服务器的虚拟化技术有要求，用virt-what命令可以推断服务器用的是什么虚拟化技术。一般有要求的都会明确提出来，否则大概就是没有。域名做小程序，做https网站等等一些操作可能需要一个域名。域名可以从freenom免费弄一个，但是如果做邮件服务器注意免费域名可能被当作垃圾邮件或者在一些地方不让用。特别注意如果是服务器在国内，所有ISP都要求域名进行备案，否则域名就算是解析到服务器也只会展示一个漂亮的阻断访问页面提醒你去备案。虽然不能访问网站但是还是可以解析到的，做邮件服务器或者ssh都可以用。httpd从这里开始进入安装，从最好装的开始。如果你希望用服务器托管网页或者你的前端程序需要访问服务器上的一些文件，那么httpd是一个很方便的选择。Apache httpd 是一个网页服务器，虽然在现在的标准下看起来可能有点老了，但是小规模场景下效果也不错，安装和使用都很简单。yum install -y httpd # httpd安装systemctl start httpd # 启动systemctl status httpdsystemctl enable httpd # 开机自动启动# systemctl stop httpd # 关闭服务Centos下，httpd的配置在 /etc/httpd/conf/ 下，用 httpd -t 可以校验修改后的配置有无语法错误。默认网页文件root在 /var/www/html现在为了保证安全，很多服务会强制要求https，比如微信小程序不能做http的访问。httpd配置https最简单的方法一定是LetsEncrept + Cerbot。官网上cerbot是通过snap安装的，需要先装snap。sudo yum install -y epel-releasesudo yum install -y snapdsudo systemctl start snapdsudo ln -s /var/lib/snapd/snap /snap # enable classic snap supportsudo snap install core; sudo snap refresh core # 更新snap安装cerbot，并添加到执行路径sudo yum remove -y certbot # 确保没有之前安装的cerbot残留sudo snap install --classic certbot # 安装cerbotsudo ln -s /snap/bin/certbot /usr/bin/certbot # 链接到执行路径Let’s Encrept并不给ip颁发证书，你需要一个网址指向自己的ip。sudo certbot --apache # 获取证书并顺手改了httpd的配置# sudo certbot certonly --apache # 只获取证书，不修改配置可能的bug： 网络问题 HTTPSConnectionPool(host=&#39;acme-staging-v02.api.letsencrypt.org&#39;, port=443): Max retries exceeded with url: /directory (Caused by NewConnectionError(&#39;&amp;lt;urllib3.connection.HTTPSConnection object at 0x7f1ac78badc0&amp;gt;: Failed to establish a new connection: [Errno -2] Name or service not known&#39;)) 这个大概是网络的问题，重新跑一遍应该就好了 VirtualHostUnable to find a virtual host listening on port 80 which is currently needed for Certbot to prove to the CA that you control your domain. Please add a virtual host for port 80.# 这是要你在80端口创建一个virtual host，可以在httpd设置中添加&amp;lt;VirtualHost *:80&amp;gt; DocumentRoot &quot;/var/www/html&quot; ServerName 域名&amp;lt;/VirtualHost&amp;gt; 找不到ssl模块Could not find ssl_module; not installing certificate.# 首先确定自己有没有ssl模块ls /etc/httpd/modules/ | grep ssl # 如果结果是空的，那需要安装mod_ssl，正常应该显示 mod_ssl.soyum install -y mod_ssl# 确定 mod_ssl.so 存在之后在 httpd.conf 中添加LoadModule ssl_module modules/mod_ssl.so# 之后重新跑申请证书就可以了目前cerbot安装已经自带更新证书了，测试自动更新sudo certbot renew --dry-run# Congratulations, all simulated renewals succeeded:到这就可以通过https访问网页了，证书自动更新，不用担心过期。除了网页之外，你可能有一些类似 Flask 的服务不从httpd走流量，而且可能不好配 https。这样可以用httpd配一个端口转发，用httpd监听一个端口的https流量，转发到一个http端口，之后一个类似 Flask 的进程监听这个http端口。响应的数据走相反方向回到用户。这样任何http的服务就可以通过httpd无痛升级到https，而且在服务器内部转发一下也不会有什么安全问题（个人认为）上面cerboot会把443端口设置成监听https的，可以按照cerboot的写法添加其他端口的监听来代理自己的服务# httpd的配置在 /etc/httpd/conf.dvi /etc/httpd/conf/httpd.conf# 这么写可以把 5000 端口的 https 流量转到接 8000 端口的 http 服务上，如果同时防火墙挡住 8000/tcp ，不向用户暴露，就可以只让用户访问https的版本了Listen 5000 https&amp;lt;VirtualHost *:5000&amp;gt; ServerName 服务器域名 SSLEngine on SSLCertificateFile /etc/letsencrypt/live/域名/cert.pem SSLCertificateKeyFile /etc/letsencrypt/live/域名/privkey.pem ProxyPass / http://localhost:8000/ ProxyPassReverse / http://localhost:8000/ &amp;lt;Proxy *&amp;gt; Order deny,allow Allow from all &amp;lt;/Proxy&amp;gt;&amp;lt;/VirtualHost&amp;gt;shellTODOshell是我喜欢linux最重要的原因，之前用windows的时候也不知道怎么用命令行，到linux之后发现真是巨方便。shell命令太多了，这里就记一些自己用的多的。菜鸟上有比较全的。for zip in `ls *.zip`; do unzip $zip; doneif [$(docker ps | wc -l) -ne 2]; then echo &quot;有情况&quot;; fi# 查看所有进程top # 如果风扇莫名开始响可以看是哪个进程在用cpu# 查看磁盘占用df # 查看各个挂载点还有多少空间du # 查看一个目录用了多少空间，默认是会递归进去du -sh # 如果只是想看一个总数 ctrl-s 冻结命令行这个时候输入的任何命令会被记录但是不会被执行。 ctrl-q 解冻命令行冻结过程中打的命令在这个时候会执行 ctrl-l 清屏 ctrl-rvimTODO对新手来说，vi是让人极其崩溃的。这里只记录一些基本的vi命令和技巧。vsftpd这个是ftp服务端程序，ftp客户端有其他的选择，但是这个个人比较熟悉。yum install -y vsftpdsystemctl start vsftpd# systemctl enable vsftpd # 自动启动三思，因为不一定时刻需要，而且没配好ftp服务端有安全隐患# 防火墙配置firewall-cmd --zone=public --permanent --add-port=21/tcpfirewall-cmd --zone=public --permanent --add-service=ftpfirewall-cmd --reload# 备份配置cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bkvi /etc/vsftpd/vsftpd.conf# 之后需要修改一些vsftpd的设置anonymous_enable=NO # disable anonymous loginlocal_enable=YES # permit local loginswrite_enable=YES # enable FTP commands which change the filesystemlocal_umask=022 # value of umask for file creation for local usersdirmessage_enable=YES # enable showing of messages when users first enter a new directoryxferlog_enable=YES # a log file will be maintained detailing uploads and downloadsconnect_from_port_20=YES # use port 20 (ftp-data) on the server machine for PORT style connectionsxferlog_std_format=YES # keep standard log file formatlisten=NO # prevent vsftpd from running in standalone modelisten_ipv6=YES # vsftpd will listen on an IPv6 socket instead of an IPv4 onepam_service_name=vsftpd # name of the PAM service vsftpd will usetcp_wrappers=YES # turn on tcp wrappers# 添加白名单# vsftpd will load a list of usernames, from the filename given by userlist_fileuserlist_enable=YES# stores usernamesuserlist_file=/etc/vsftpd/vsftpd.userlist# 白名单，只有在上面文件里的用户才能登录userlist_deny=NO# 限制只能访问自己的 ~ 路径# chroot_local_user=YES# allow_writeable_chroot=YESuserlist_enable=YES + userlist_deny=NO 的意思是只允许 /etc/vsftpd/vsftpd.userlist 中的用户登录。所以将想要允许登录的用户添加到这个文件里，一行一个。之后重启vsftpd服务，如果显示 500 OOPS: bad bool value in config file for: 某个配置变量，那么可能是这行后面有空格之类造成的，可以用下面这行处理一下sed -i &#39;s,\\r,,;s, *$,,&#39; /etc/vsftpd/vsftpd.conf到这ftp基本就配置好了并做了简单的安全措施。本地链接服务器的软件推荐FileZilla。如果ftp协议不好用可以试一下sftp，个人经验sftp比ftp容易成功。ftp能做很多事，如果是生产环境安全方面肯定需要额外差资料研究，这些大概是不够的。MysqlMysql需要通过Oracle维护的单独的一个repo安装，可以下载官网的rpm添加repo之后安装，参考这个教程。但是国内一般这种方法都慢到不行，清华源有这个repo的镜像，参考官方介绍添加repo，下载速度一般都是很快的。下载官方repowget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpmsudo rpm -ivh mysql-community-release-el7-5.noarch.rpmyum update -y添加清华源repoecho &quot;[mysql-connectors-community]name=MySQL Connectors Communitybaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-connectors-community-el7-$basearch/enabled=1gpgcheck=1gpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql[mysql-tools-community]name=MySQL Tools Communitybaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-tools-community-el7-$basearch/enabled=1gpgcheck=1gpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql[mysql-5.6-community]name=MySQL 5.6 Community Serverbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-5.6-community-el7-$basearch/enabled=0gpgcheck=1gpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql[mysql-5.7-community]name=MySQL 5.7 Community Serverbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-5.7-community-el7-$basearch/enabled=1gpgcheck=1gpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql[mysql-8.0-community]name=MySQL 8.0 Community Serverbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-8.0-community-el7-$basearch/enabled=1gpgcheck=1gpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql&quot; &amp;gt; /etc/yum.repos.d/mysql-community.repo可能的bug：Retrieving key from file:///etc/pki/rpm-gpg/RPM-GPG-KEY-mysqlGPG key retrieval failed: [Errno 14] curl#37 - “Couldn’t open file /etc/pki/rpm-gpg/RPM-GPG-KEY-mysql”一个校验的问题，最简单的workaround是直接禁用校验。在配置里修改 gpgcheck=0 就能下了，但是这种方法不安全。添加完repo就进行安装sudo yum install -y mysql-serversudo systemctl start mysqldmysql_secure_installation # 加强安全，有些版本的初始密码在安装的log文件里，有些默认是空密码如果安到一半出错想要重来，完全卸载mysql用下面两行。如果只是卸了软件，那些忘了的密码之类的还存在数据文件里，装回来还是会需要密码。yum remove mysql mysql-servermv /var/lib/mysql /var/lib/old_backup_mysql # 挪走数据文件，直接删了也行，如果没什么东西备份其实迁移也可以看成是先备份之后原样创建，很多数据库工具都有备份或者迁移功能，但是我使的workbench之前各种出问题。其实mysql自带的mysqldump就能导出创建表格和插入数据的代码，在少量数据的情况下用起来很方便mysqldump -u root -p &amp;gt; out.sql这样在out.sql中就有了一份创建这个数据库并插入代码的脚本。直接用可能会有问题，有外建约束的时候需要先创建被引的表，dump应该不管这个，之后就是dump的时候会声明字符集，插入到新的数据库如果不支持删掉字符集的声明就行。PHPphp是世界上～ 好的我不说了 /滑稽。貌似CentOS上现在yum的repo只到php5，像wp都要求php7了，最简单的php5安装yum install -y phpsystemctl restart httpdphp -vecho &quot;&quot;&quot;&amp;lt;?php phpinfo();?&amp;gt;&quot;&quot;&quot; &amp;gt; /var/www/html/test.php之后访问 hostname/test.php 可以看到php版本之类的信息。如果网页打不开注意看防火墙设置。php官方推荐通过remi安装，可以自己指定版本，如果有版本要求都推荐这种方法．sudo yum install -y epel-release yum-utilssudo yum install -y http://rpms.remirepo.net/enterprise/remi-release-7.rpmsudo yum install -y php php-common php-opcache php-mcrypt php-cli php-gd php-curl php-mysqlndphp -vecho &quot;&quot;&quot;&amp;lt;?php phpinfo();?&amp;gt;&quot;&quot;&quot; &amp;gt; /var/www/html/test.phpWordpress有了httpd，mysql和php就可以跑wordpress了。# 创建sql表和用户mysql -u root -p# 输入密码CREATE DATABASE wordpress;CREATE USER wordpressuser@localhost IDENTIFIED BY &#39;password&#39;;GRANT ALL PRIVILEGES ON wordpress.* TO wordpressuser@localhost IDENTIFIED BY &#39;password&#39;;FLUSH PRIVILEGES;exit# 获取wpcd ~wget http://wordpress.org/latest.tar.gztar xzvf latest.tar.gzsudo rsync -avP ~/wordpress/ /var/www/html/ # 保留权限复制mkdir /var/www/html/wp-content/uploadssudo chown -R apache:apache /var/www/html/*# 之后访问网址　http://example.com/wp-admin/install.phpInfluxDB上面已经装了一个数据库Mysql，但是如果你的需求是时序数据，比如物联网一些传感器定时产生数据的这种，influxDB是专门针对这个的。比如一定时间窗口下的聚合，mysql实现应该就比较麻烦，influx有默认支持。8086/tcp8088/tcpinflux通过yum安装，先添加源cat &amp;lt;&amp;lt;EOF | sudo tee /etc/yum.repos.d/influxdb.repo[influxdb]name = InfluxDB Repository - RHEL \\$releaseverbaseurl = https://repos.influxdata.com/rhel/\\$releasever/\\$basearch/stableenabled = 1gpgcheck = 1gpgkey = https://repos.influxdata.com/influxdb.keyEOF之后安装和启动sudo yum install influxdb # 企业界的东西，装起来就是方便systemctl start influxdb关于怎么使用，官方教程GrafanaGrafana应该是最流行的监控平台，可以对数据库中的数据用多种图表的方式进行展示。老规矩，先添加Grafana源。echo &quot;[grafana]name=grafanabaseurl=https://packages.grafana.com/oss/rpmrepo_gpgcheck=1enabled=1gpgcheck=1gpgkey=https://packages.grafana.com/gpg.keysslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crt&quot; &amp;gt; /etc/yum.repos.d/grafana.repo之后安装启动，添加防火墙规则sudo yum install -y grafanasudo systemctl daemon-reloadsudo systemctl start grafana-serversudo systemctl status grafana-serverfirewall-cmd --zone=public --add-port=3000/tcp --permanentfirewall-cmd --reloadPython3Centos7 自带的都是2.x的 python，一些包现在已经开始drop对2.x的支持，比如cv2的安装就很费劲，因此上一个3.x的 python 是很有必要的。最初写这个的时候Centos上的repo里最高只到py34，pip都装不上。但是yum已经支持到了py36，而且带pip。sudo yum install -y python3如果需要更高版本，py36以上目前我只知道可以通过源码编译安装。下面的脚本在37,38,39中的一个版本中都测试通过。# 首先做一波升级sudo yum update -y# 因为是编译安装所以需要装一波编译依赖yum -y groupinstall &quot;Development tools&quot;yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-develyum install -y libffi-devel zlib1g-devyum install zlib* -y# python.org 下载 .xz 源码压缩包VERSION=3.7.9 # 3.7.9, 3.8.8, 3.9.2 测试通过# 从python官网下载可能较慢，华为有一个镜像。不带最后的 /base_url=https://www.python.org/ftp/python # https://mirrors.huaweicloud.com/pythonwget ${base_url}/${VERSION}/Python-${VERSION}.tar.xztar -xvf Python-${VERSION}.tar.xz # 解压到当前目录mkdir /usr/local/python3cd Python-${VERSION}./configure --prefix=/usr/local/${VERSION} --enable-optimizations--with-ssl# [TODO] with-ssl 不好使# 第一个指定安装的路径，不指定的话，安装过程中可能软件所需要的文件复制到其他不同目录，删除软件很不方便，复制软件也不方便# 第二个可以提高python10%-20%代码运行速度time make &amp;amp;&amp;amp; make install # 之后需要编译很长时间，看起来比较吃CPU和IO# 编译应该不会出什么问题，如果正常结束了就创建到可执行程序的软链接ln -s /usr/local/${VERSION}/bin/python3 /usr/local/bin/python3ln -s /usr/local/${VERSION}/bin/pip3 /usr/local/bin/pip3# 到这就可以在命令行直接运行 python3 了python3 # 之后就能看到版本了，ctrl+d 退出# 安装 pipcurl -O https://bootstrap.pypa.io/get-pip.pypython3 get-pip.py换pip源如果服务器在国内，从pypi下载是比较慢的。一些云服务厂商会提供pypi镜像，内网下载会很快。mkdir ~/.pipecho &quot;[global]index-url=https://mirror.baidu.com/pypi/simple&quot; &amp;gt; ~/.pip/pip.configPaddle-ServingTODO完善内容甲方有一个深度学习的推荐需求，因此做一个paddleserving。之前用的tfserving是跑在docker容器的，因为当时也菜装的极其绝望，推理相应速度飘忽补丁而且经常自己死掉。但是paddle-serving看起来很简单 paddle官网 paddle-serving github 20年3月paddle-serving 还没有py3的版本，git上说4,5月份会有，pip找不到包的时候注意 之后我这里pip安装有报错，简单来说是这样error: command ‘gcc’ failed with exit status 1 —————————————- ERROR: Failed building wheel for subprocess32正常pip应该是不会有问题的，这里是因为少依赖yum install python-develMail服务器一般不希望装很多东西，如果就是想发个邮件可以用服务器smtp控制其他邮件服务发，服务器上不需要装。服务器就做了很简单的设置vi /etc/mail.rcset from=邮箱账号 smtp=smtp.qq.comset smtp-auth-user=邮箱账号 smtp-auth-password=邮箱密码set smtp-auth=loginecho &quot;邮件主题&quot; | mail -s &quot;邮件内容,这是测试邮件&quot; xx@163.com之后就发出去了。但是邮件服务那边必须开通smtp服务，一般在邮箱的设置里面。需要提一下的是qq邮箱smtp服务开通之后邮箱用的密码不是qq密码，而是开通的时候给的密码，写的时候不要写错了。而且开了smtp要注意发出去的邮件，之前遇到过smtp的密码被破了，自己的邮箱被人用来批量发开发票的广告。。桌面虽然服务器基本不需要桌面，但是有一些需求可能会需要。Gnome的桌面比较重，个人比较喜欢XFCE。yum -y install epel-releaseyum -y groupinstall &quot;X Window system&quot; # 大概270个包yum -y groupinstall &quot;Xfce&quot; # 大概140多个包systemctl isolate graphical.target # 开启桌面Gnome的安装也很简单yum groupinstall -y &quot;GNOME Desktop&quot; # 大概1200个包# 网上的教程中还有装这个的，少上100个左右的包，效果应该是一样的yum -y groupinstall &quot;Server with GUI&quot; # 大概1000个远程GUIhttps://linuxize.com/post/how-to-install-and-configure-vnc-on-centos-7/TODO服务器本身没有显示器，但是有很多方案把服务器上的图形界面展示到自己电脑的屏幕上。这个方向基本两个解决方法，VNC和X11forwarding，forwarding比较好弄，但是一般比较卡，需要好好配置。vnc可以在本地关掉窗口之后还继续运行，很方便。yum -y groupinstall X11 # 大概300个包sudo yum install -y tigervnc-serveruseradd vncsudo cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.servicesudo vi /etc/systemd/system/vncserver@:1.service# 把里面的用户名改了sudo systemctl daemon-reloadsudo systemctl enable vncserver@:1.servicesudo systemctl start firewalldfirewall-cmd --add-port=5901/tcp --permanent# sudo firewall-cmd --permanent --zone=public --add-port=5904-5905/tcpsudo firewall-cmd --reloadsu vncvncserversudo systemctl daemon-reloadsudo systemctl restart vncserver@:1.service# 关闭一个桌面vncserver -kill vultr.guest:1清理服务器用的时间长了可能各种log，各种cache之类的东西会占很大的磁盘，因此可以考虑定期进行清理。需要注意只要是删除东西的操作都是危险的，要知道自己在干什么。完整教程用户管理添加一些低权限的用户给别人使用能防止意外的故障。useradd [username]passwd [username]gpasswd -a username wheel # 添加sudo权限userdel [username]Python webflask + gunicorn + supervisor当你通过命令行登录服务器启动了一个进程后，退出服务器会默认终止这个进程。如果你不想进程随着退出ssh被kill掉可以使用nohup命令。如果你有一个flask app 在 flask_app.py 里，那么可以执行nohup python flask_app.py &amp;amp;但是nohup有时候很不稳定，而且没有进程出问题后自动重启，这显然不是一个好的方法，flask本身的WSGI不是为了生产设计的，也不是很稳定。推荐使用gunicorn这种生产级别的wsgi。如果要https可以用端口映射的方式，不一定要在gunicorn中配https。supervisor和systemd类似，是用来保证进程一直运行的，如果进程除了问题supervisor可以重启进行，保证后台的稳定。# 安装yum install supervisor# 设置一般在 /etc/supervisord.conf ,至少大概在etc下systemctl daemon-reloadsystemctl start supervisordsystemctl status supervisordsystemctl enable supervisord# 到这supervisord本身应该就起来了，之后编辑supervisord.conf添加program[program:test]directory=/path/to/executecommand=python3 main.pyuser=rootautostart=trueautorestart=trueredirect_stderr=truestderr_logfile=/path/to/errlogstdout_logfile=/path/to/stdlogsupervisorctl reread # 如果改了config文件，这个命令加载新的supervisorctl stop [appname]supervisorctl start [appname]supervisorctl restart [appname]在调试过程中可能有时候没有正确关闭服务，这样就会出现address already in use。这个时候重启肯定可以释放端口，但是有点麻烦，可以通过下面一行代码找到占用端口的进程+杀掉它。慎用，他不管这个端口是什么服务fuser -k 4000/tcpRuby主要是为了gollum wiki要装ruby，把ruby和gollum都记一下。ruby貌似不自举，写这个记录的时候基于c的ruby一个依赖有bug，不知道怎么解决，所以用的jruby，安装教程。装ruby的时候不写版本号写jruby就行。之后直接yum install -y epel-releaseyum install -y gogem install -y gollumgollum # 开始运行软件版本TODO详细研究sudo alternatives --config cmake" }, { "title": "玩转Github Pages", "url": "/posts/Github-Page/", "categories": "Tool, Github", "tags": "Blog, Jekyll, Github", "date": "2019-08-08 11:33:00 +0800", "snippet": "Github Pages是Github的一个免费静态网页托管服务。可以用来搭个人博客，项目简介网页，组织官网（比如给实验室做个官网）等。本文将详细介绍Pages的使用方法（非常简单，最快10分钟就可以起一个个人博客）。开始前先进一段简介，也可以直接跳到做项目主页和个人博客的具体步骤。Pages简介Pages的优点是不需要配服务器，数据库这些环境，简单稳定，而且免费。这使得Pages很适合做个人博客，项目主页，企业官网这一类纯展示性质（可能也不产生收益 :joy:）的站点。其缺点是只能托管静态网页，意思是对于每个用户网站展示的内容都是一样的。这不意味着Pages里不能有任何动态的元素，比如可以结合Issue实现博客评论。但是要做功能复杂的网站或者很多的数据处理，大概还是有一个服务器后台会更方便。Pages在项目每次更新后会做两件事： 把项目指定分支，指定文件夹中的内容用Jekyll转成网站 托管这个网站不过Jekyll只会转markdown文件，所有的网页都会原样保留，所以直接上传网站只是白嫖一下托管也是可以的。这种方案可以用Jekyll以外的静态网站生成工具，比如hexo和hugo，过程和用Jekyll本地构建后直接上传网站相同。总结起来用Pages主要有三种姿势 上传markdown，直接让Pages用Jekyll构建成网站托管 上传markdown，用Github Action构建成网站托管 直接上传网页，让Pages托管第一种方式最简单也很方便，但是Pages的Jekyll只提供了13个为项目主页设计的单页主题，所以通常也只有项目主页用第一种方式。个人博客和组织官网用第二种的居多，直接Fork主题项目就行，够灵活而且不用本地配环境，Action脚本通常Jekyll主题都会带。直接上传网页灵活性最高，但是稍微麻烦一些。除非是自己直接写的网页否则感觉第二种方法就够用了。Github这段面向之前完全没用过Github和git版本管理工具的纯小白，简单说说如何注册Github，创建项目和git是什么。Github是一个代码托管平台，开发者将代码放在这个平台上面，方便一个项目的多个开发者同步代码，同时也有助于开源项目的传播。注册需要一个邮箱，访问Github注册页面，按提示操作就行。Github上的项目可以自己新建也可以复制别人的，就做博客来说直接复制主题项目比较多。Fork的意思就是将别人的一个项目复制一份，存到自己的Github账户下。在每个项目的右上角都有一个Fork按钮点击之后就会跳转到一个自己的新项目，项目的内容和名称都和原来的项目一样，只不过这个项目是属于自己的，可以进行修改。如果是要创建自己的项目，点主页左边一个绿色的创建新项目（New）按钮就行。一般建议添加一个README，空项目是没法直接pull的，需要本地先创建之后推上去稍微麻烦一点。git是一个代码版本管理工具，简单来说可以让你在写代码过程中创建一些存档点。如果只有一个开发者那么这些存档点就是一条直线，一个比一个新，像下面图里的红线。如果有多个开发者同时对项目做修改，存档点可以有一些平行的路径，像下面图里的蓝线和黄线。就做个人博客来说不需要了解很多的git知识，操作也不需要命令行，有很多带界面的git软件比如Github Desktop。做博客最简单的方法是fork一个主题项目，将项目pull到本地，进行修改，之后再push回github的服务器上。后面用到的时候回说具体怎么操作。项目主页从最简单的开始，先介绍怎么做项目主页，也就是怎么用Pages直接把markdown变成一个能访问的网站。首先打开一个Github项目，点进Settings-&amp;gt;Pages页面。一个没开启Pages的项目应该是这样的Source这里选markdown所在的Branch后面的文件夹选项是指定在这个Branch下去哪找markdown文件。如果只在根目录下有一个README.md的话保持默认/(root)就行，如果文档是分成多个文件可以都放到docs文件夹下，选择/docs。保存。稍等一会访问上面这个网址就能看到网页了。Pages用一个Enviroment进行静态网站生成和托管，查看进展的方法是首先回到项目主页在右下角可以看到一个Enviroments，点进那个github-pages就可以看到部署的执行情况，刷新几次就会看到一条新的部署记录，点view deployment就会跳转到网页了。默认部署没有主题看起来大概比较素，可以在Settings -&amp;gt; Pages -&amp;gt; Theme Chooser -&amp;gt; Choose a theme这里选一个主题。点击之后会看到主题的预览，点Select Theme选中一个主题。这个时候Pages会在代码里创建一个_config.yml文件，记下你选的主题。内容类似这个等一会Pages更新之后就能看到带主题的网页了。Pages给了12个主题，做项目主页不建议用这12个之外的。Pages的文档中描述了怎么使用外部主题但是Pages的Jekyll环境比较简单，很多主题都会缺gem依赖，而且部署过程貌似也没有详细的log，出问题了大都跟下面一样只有一句构建失败，不太好debug。想用第三方主题建议用Action创建一个环境编译。个人博客下面就到了这篇的重头戏，用Pages部署个人博客。过程非常简单，选一个主题，用Jekyll或者类似工具（如hexo，Octpress）把markdown构建成html，之后推到Github项目中就完成了（个人只用过Jekyll所以下文也是针对Jekyll写的，但用其他工具的流程也是一样的）。构建的这一步通常用Github Action，非常方便，搭建的过程10分钟就能搞定。本地构建麻烦一些，但是灵活度高，下文将分别介绍。主题如果是前端大佬大可以用html，css，js，Liquid这些语言自己搞一个主题，不过Jekyll有很丰富的主题生态可以即fork即用。选择主题的指导原则是好看和好用。好看纯看个人审美，没什么好说的。好用是希望主题的功能尽可能丰富。一些常见的功能包括： 博客内搜索 自动生成sitemap：便于搜索引擎收录，搜索引擎大概会是博客最主要的流量来源 文章标签和分类：博客首页一般都按发表顺序展示文章，内容多了之后标签和分类会比较实用 文章目录：长文用的上 发表时间，修改时间：发表时间一般都是有的，修改时间要看git记录不是所有主题都有 深色模式 代码块 数学公式 …这些功能主题就算没有也都可以自己加，不过带的话可以省很多麻烦。此外主题一般都是Github项目，质量高的通常Star和Fork数比较多，更新频率高。好的主题一般教程详细，部署过程中也不容易出问题。本文以我正用的chirpy为例，更多的主题可以逛逛下面这些网站 Github 上的 #jekyll-theme jamstackthemes.dev jekyllthemes.org jekyllthemes.io jekyll-themes.com推荐Fork主题，优点是用Github最近出的Fetch Upstream跟着上游更新主题比较方便。Fork项目之后需要按照 用户名.github.io 格式改项目名，比如我Github用户名是linhandev，那项目名就是 linhandev.github.io。点Settings第一个设置就是。如果名字冲突要删之前的博客千万千万记得保存内容，之前丢过好几波写好的文章。。。看一看主题的 README 对使用方法的介绍，一般都会仔细的写Fork之后需要进行哪些操作，比如chirpy会需要运行一个脚本。看文档虽然无聊，但绝对比出问题之后一通debug节省时间。Jekyll的主要设置都在根目录下的 _config.yml 文件里，比如网站标题 title ,副标题 tagline，时区 timezone，头图 avatar，和一些社交媒体配置之类的。走一波这个文件，一般都有注释每个设置是啥，把想改的改一改。Action构建Action写起来稍微复杂，不过大多数主题要么自带用Action构建的脚本，要么可以直接用Pages的环境构建。写这部分的目的主要在于方便在博客构建失败的时候Debug，以后可能会更新这个Action具体怎么写。如果主题没提供这个脚本，自己对Action也不熟悉的话，那本地构建会更简单。Github Action会在项目有一些动作之后触发，比如push，开Issue之类。Action的配置在项目的 .github/workflows 文件夹下。首先一定看一下主题README.md里有关开始使用的部分，一些主题会有一个初始化的脚本，之前用Chirpy的时候就因为没仔细看文档走了一堆弯路。每次push更新之后Action会自动执行，在项目的代码页面commit的左边会有一个图标，就是下图红框的位置Action执行过程中是一个黄点，执行成功是一个绿色的对号，如果看到一个红叉就是执行出问题了。执行成功之后点代码左上角的下拉菜单看看是不是多出一个branch修改Settings-&amp;gt;Pages里的设置，将Source改成这个branch如果commit左边图表是红叉可以看一下Action执行的log来排查具体是什么问题。 点项目上面的Action能看到所有的执行 点进其中的一次执行是这样 点在那个continus-delivery位置的按钮（不一定叫一个名字）可以看到具体的执行log。展开出错的部分就可以看到具体是什么问题了。第一次执行Action需要创建环境，下一堆依赖应该会比较慢，可能要几分钟。chirpy的Action脚本会保存ruby的环境，以后每次执行大概只需要半分钟。Action执行成功后Pages还需要几分钟才会更新，只要Action执行成功了这次发布就没什么问题，等着就行。本地构建使用Action构建很方便，主要的缺点是每次push之后需要等上几分钟才能看到效果，本地跑Jekyll可以实时编译，保存之后刷新网页就能看到更新。直接推网页Pages更新的速度也稍快一些。安装环境Jekyll用Ruby编写，本地运行需要装Ruby和Ruby的包管理工具RubyGem，这里记Arch Linux的安装步骤，其他系统可以参考官方安装文档sudo pacman -S ruby base-devel安装的过程中遇到个小问题，pacman下清华源几个文件一直失败。解决的方法是上清华源的网站，直接下载对应的安装包文件之后 pacmsn -U 安装。装好ruby之后换源，之后装jekyll，bundle# 添加清华源并移除默认源gem sources --add https://mirrors.tuna.tsinghua.edu.cn/rubygems/ --remove https://rubygems.org/gem sources -l # 列出所有源，应该只有TUNA一个gem install jekyll bundler # 装包bundle # 让bundle安装jekyll的依赖jekyll # 测试安装是否正确# 头两行输出应该是# A subcommand is required.# jekyll 4.2.1 -- Jekyll is a blog-aware, static site generator in Ruby如果上面最后一行输出的是找不到 jekyll 命令，那应该是可执行文件路径里没有gem中的bin文件夹，仔细看看gem install命令的输出应该针对这个问题有提示，把bin的路径添加到PATH里就行。gem environment # 找输出里的 GEM PATHS 部分export PATH=$PATH:[上面的gem path] # 比如Arch上是 /usr/lib/ruby/gems/3.0.0jekyll # 试试改的对不对# 如果能找到命令了就把这行写到 ~/.bashrc 里，这样打开一个新命令行依旧有效echo &#39;export $PATH=$PATH:[上面的gem path]&#39; &amp;gt;&amp;gt; ~/.bashrc # 必需单引号，双引号变量会替换成值到这编译Jekyll的环境应该就配置好了，下一步进行构建和push。构建和push首先把Github上的项目clone到本地，创建新项目或者Fork主题，项目名要求是 Github用户名.github.io。前面已经说过了。如果创建新项目添加一个空的Readme方便后面clone。完成后把项目 clone 到本地。git clone https://github.com/[username]/[username].github.iocd [username].github.io # 进到项目里如果是新项目将主题的所有文件放到项目里。应该有_config.yml，index.html，_post之类的一堆文件和文件夹。这个时候就可以本地构建了jekyll build # 构建结果在_site文件夹里# 或者jekyl b # b是简写，效果是一样的此外还可以跑一个本地的网站展示博客，每次markdown文件保存后网站都会自动重新构建，刷新页面就能看到修改jekyll serve # 之后访问 Server address: 那个网址就能看到# 或者jekyll s # 简写构建成功之后给构建出来的网页文件单独创建一个branchgit checkout # 查看一下当前分支叫什么，一会还要回来git branch gh-page # 创建 gh-page branchgit checkout gh-page # 切换到新branchgit rm -r * # checkout会把原来分支的所有文件都带过来，删掉它们git commit -m &quot;clean up&quot;git push --set-upstream origin gh-page # 推到 Github上git checkout main # 返回之前的branch分支创建完成了，build并推到 Github 上。下面的脚本有删除的代码，一定确定好自己在哪个branch上，否则可能误删markdown文件。# 在主分支构建git checkout mainjekyll build # md转html# 将 _site 中生成的html网站放到 gh-page 分支的根目录里git checkout gh-pagemv _site .siterm -rf *mv .site/* .rm -rf .sitels # 应该有404.html，main.html这样的文件# 在 gh-page 分支 pushgit add *git commit -m &quot;Update Blog&quot;git push# 在 main 分支 pushgit checkout mainrm -rf _sitegit add *git commit -m &quot;Update Jekyll Blog&quot;git push到这复杂的部分基本就完成了，最后跟前面一样改一下Pages的Source。到 Github 项目的Settings-&amp;gt;Pages里，将 Source 设成 gh-page，/root，保存。等几分钟网站应该就可以访问了。博客评论你可能希望大家在看完博客之后给点反馈。文章评论不是一个静态的功能所以光靠Github Page实现不了。我了解到有两种实现方案 用自己搭建的或第三方的评论服务 用Github API实现最开始我是用的第三方评论服务hyvor，当时试运营是免费的但是现在已经收费了。这种服务套餐的量一般都很大，比如hyvor起步的$5/月套餐就有10w page view。估计我有生之年博客都不会有这么大的流量。/笑哭Github的服务依旧更加良心。 /笑哭 目前发现了两个基于Github Issue给文章添加评论的项目 utteranc gitalkutteranc看起来配置简单一点，gitalk的使用方法以后添加。utteranc会给每篇文章创建一个Issue，用户对文章的评论会保存为Issue下的回复。评论的时候会需要用户用Github账户登陆，之后授权utteranc。安装过程很简单 访问这个网址，在Gtihub上安装utterances app可以只给博客一个项目的权限 安装完成后会打开utteranc网站，按照引导进行设置，先写项目名 选择每篇文章Issue的格式这里要注意utteranc会按照配置的格式去找文章对应的Issue，基本上是根据文章的标题或者markdown文件名。如果修改了文章的标题或者md文件名也需要修改对应Issue的名字，否则就找不到任何评论。个人感觉设第一个是最好的，文件名估计不会有文章名改的多。 之后可以填一个utteranc创建Issue的标签，作用不大 最后选择一个和主题视觉协调的配色下面能看到一段代码，把它插入到文章模板里正文下面的位置就可以用了。Chirpy的文章模板是在 _layouts/post.html，别的主题也都类似。最后的效果本地编辑环境markdown不是所见即所得，而且插入图片一般有点费劲。本地环境可以很好的解决这些问题，简化写作流程。个人很喜欢Atom，在另一篇文章中记了如何配置Atom写markdown，可以参考。搜索引擎收录一般个人博客的流量都不大，Chirpy主题的作者甚至不推荐大家开文章浏览量功能，怕打击博主的创作热情 /笑哭 不过如果你的博客有一些高质量的内容，搜索引擎是可以带来一些流量的。搜索引擎优化是一门学问，但如果只是很佛系的告诉搜索引擎：“我有个网站，你爬不爬看着办”，那只要添加robots.txt，之后提交一个sitemap就行。sitemap顾名思义就是网站的地图，告诉爬虫我这个网站都有些什么页面可以访问。大多数主题都会带这个功能，访问 [github id].github.io/sitemap.xml ，如果不是404那就是有sitemap的。比如我的长这样如果你的主题不带sitemap也可以自己添加robots.txt是用来告诉搜索引擎网站上哪些网页该爬，哪些网页不该爬的。可以访问 [github id].github.io/robots.txt 看看自己有没有这个文件。如果没有的话，在项目根目录中加上一个robots.txt文件就行，一个最简单的写法是User-agent: *Disallow: /norobots/Sitemap: https://[github id].github.io/sitemap.xml这个文件告诉搜索引擎所有类型的爬虫都可以爬这个网站，除了 /norobots/ 路径下的所有页面都可以爬取和网站的sitemap在哪。robots.txt和sitemap俱全就可以向搜索引擎提交网站了。这里需要用到各大搜索引擎的站长工具，webmaster或者search console。下面是一些常用的搜索引擎站长工具链接。 百度 Bing Google 搜狗 头条 神马 360提交的过程类似： 注册帐号 证明网站是你的 提交sitemap证明这一步通常有多种方法，对于Pages来说最方便的应该是添加文件。只需要将文件下载下来扔到项目根目录下，之后把修改推上Github就行。注意这个文件要放在项目目录而不是构建出来的网页目录，否则重新构建会把这个文件抹掉。第二种常用的方法是在网站header中加入meta tag，这种方法的优点是添加多个搜索引擎的话项目的根目录整洁一些（如果这可以算优点的话）。tag的内容是一串随机字符。比如我的bing搜索验证tag是&amp;lt;meta name=&quot;msvalidate.01&quot; content=&quot;D657F7EB150CC9886DA47F92C4D34ED6&quot; /&amp;gt;在Chirpy主题中网站的header部分在 _includes/head.html定义，如果你的主题目录结构不一样可以在项目里搜一下head开头的文件。找到之后这行代码放到head.html的head部分就行了。验证身份后找带sitemap的tab，点进去输入sitemap网址就大功告成了。就我这个网站添加多个搜索引擎之后不多的流量来看，bing国内版似乎是对新网站最友好的，大概提交sitemap 3 4天之后就能看到来自cn.bing.com的流量。Google也有一两个，其他国内的搜索引擎大多数连爬都懒得爬。流量统计自定义域名Pages的默认网址是固定的，比如个人博客都是 用户名.github.io，项目网站都是 用户名.github.io/项目名 。但是Pages也支持自定义域名。要用自定义域名非常明显首先要自己有一个域名，这个在各大云厂商都能买到，大概的过程是 到百度，阿里，腾讯这样的云服务上注册一个帐号 实名认证 找到域名产品 选一个下单就可以了。价格跟很多因素有关，比如域名长度，顶级域名是什么，买多久之类的，大概每年几十。如果不想花钱也可以到Freenom申一个免费的。//: # (TODO:freenom怎么申请)在域名解析的后台将这个域名CNAME解析到 username.github.io，之后在项目的 Settings -&amp;gt; Pages 里面填写自己的域名。这个时候 gh-page branch里会多一个CNAME文件，本地注意pull一下否则会冲突。在main分支的根目录里也加入这个文件。之后就可以使用自己的域名访问了。之前从自定义域名转换回 Github 给的免费域名过程中遇到一点麻烦，输入免费域名总是直接跳转到之前解析的自己的域名，之后页面显示Github的404。这种情况清一下浏览器的cache就好了。结语到这基本上Github Pages的基本用法就介绍完了。这篇文章还会不断更新进行更正和丰富。如果使用过程中有任何问题也欢迎在下方评论留言。" } ]
